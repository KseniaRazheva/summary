'use strict';

//const arr = [5, 5, 5];

//function grvr() {
    
//}

//const str = "dfghhffds";

// установила расширение eslint
// npm init
// npm init @eslint/config

// появились файлы package-lock.json, package.json, .eslintrc.js
// в .eslintrc.js комментирую // "extends": "eslint:recommended",


//урок 21. Логические операторы (33 минуты)


//script.js


// const hamburger = true;
// const fries = true;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// } 
//Я сыт! так как условие выполнено и hamburger true & fries true


// console.log((hamburger && fries)); //true просто вернуло логический тип данных, результат логических операций - логическое булевое значение
// если одно из блюд будет отсутствовать мы получим false


// const hamburger = true;
// const fries = false;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// } //результата нет в консоли потому что условие не выполнилось а блока else нет


// const hamburger = true;
// const fries = false;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// }
// console.log((hamburger && fries)); // false


// const hamburger = 5;
// const fries = 0;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// }
// //ответа нет так как условие не может быть выполнено, это подводит к теме "динамическая типизация в джаваскрипте" которую будем изучать позднее, строка может стать числом, число может стать строкой, что угодно может стать логическим значением
// humburger & fries нужно если сайт будет по продаже товаров, показывать пользователю информацию сколько товаров есть на сайте и что делать если нет картошки и вместо сообщения "я сыт" пользователю будет написано "товар закончился на складе"

// пять сущностей которые всегда будут false: 
// 0, 
// пустая строка "", 
// null(нулевой), 
// undefined(неопределенный), 
// NaN (not a number - не число)
// все остальное всегда будет true

// таблица приоритетов операторов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

// строго равно === это пункт 10,
// логическое И && это пункт 6
// приоритет 20 самый высокий, значит вначале выполнится пункт 10 строго равно, а только потом пункт 6 логическое и, пункт 1 внизу и выполняется самым последним


// const hamburger = 2;
// const fries = 1;

// if (hamburger === 3 && fries === 1) {
//     console.log('Все сыты!');
// } else {
//     console.log('Мы уходим');
// } // так как в кафе есть только 2 гамбургера и 1 картошка, а нам надо 3 гамбургера и 1 картошку - условие не выполнено (мы не получаем что хотим) поэтому - мы уходим. так же можно было в скобках условия if написать (hamburger === 3 && fries)


// const hamburger = 2;
// const fries = 1;

// if (hamburger === 3 && fries === 1) {
//     console.log('Все сыты!');
// } else {
//     console.log('Мы уходим');
// } // так как в кафе есть только 2 гамбургера и 1 картошка, а нам надо 3 гамбургера и 1 картошку - условие не выполнено (мы не получаем что хотим) поэтому - мы уходим. так же можно было в скобках условия if написать (hamburger === 3 && fries)


// оператор И возвращает первое ложное значение на котором он остановил свою работу:
// const hamburger = 3;
// const fries = 1;
// const cola = 0;

// console.log(hamburger === 3 && cola && fries) //0 (это значение колы)

// console.log(1 && 0); //0 так как 1 это всегда true, а 0 это всегда false а значит ноль

// console.log(1 && 5); // true и консоль возвращает последнее значение а это 5

// console.log(null && 5);// null - сравниваем неправду (нул это ничего) и что-то и консоль возвращает первое неправильное значение false

// console.log(0 && 'hdxtyhjx');//0 - сравниваем 0 неправду false и строку и поэтому получаем ноль потому что оператор && и запнулся на первом неправдивом значении


// и запинается на лжи, или запинается на правде


// const hamburger = 3;
// const fries = 0;
// const cola = 0;

// if (hamburger || cola || fries) {
//     console.log('Все довольны!');
// } else {
//     console.log('Мы уходим');
// }
// // Все довольны! (так как нам нужен гамбургер или кола или картошка)


// const hamburger = 0;
// const fries = 0;
// const cola = 0;

// if (hamburger || cola || fries) {
//     console.log('Все довольны!');
// } else {
//     console.log('Мы уходим');
// }
// // Мы уходим (так как условие не выполнилось, нам нужен гамбургер или кола или картошка)


// const hamburger = 0;
// const fries = null;
// const cola = 0;

// if (hamburger || cola || fries) {
//     console.log('Все довольны!');
// } else {
//     console.log('Мы уходим');
// }

// console.log(hamburger | | cola | | fries);
// // 
// Мы уходим 
// null
// последнее значение которое возвращает ложь это fries и его ответ это null


// let johnReport, alexReport, samReport, mariaReport = 'done';
// console.log(johnReport | | alexReport | | samReport | | mariaReport); //done


// приоритет операторов:
// вначале сравнение строго равно === пункт 10
// потом логическое И && пункт 6
// и только потом логическое ИЛИ | | пункт 5


// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// if (hamburger === 3 && cola === 2 | | fries === 3 && nuggets) {
//     console.log('Все довольны');
// } else {
//     console.log('Мы уходим');
// } //Все довольны
// (правда и неправда) или (правда и правда)
// false или true


// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// console.log(hamburger === 3 && cola === 2 || fries === 3 && nuggets); //2
// //правда и неправда это false про этот кусок забываем и смотрим на правый кусок там правда и правда, первая правда = 3, вторая правда = 2 и в итоге консольлог возвращает ответом последнюю правду = 2 (сравнивает левый кусок там ложь и правый кусок там два и возвращает первое правдивое выражение = 2)


// самый высокий приоритет у скобок ( )
// например
// console.log(hamburger === 3 && (cola === 2 | | fries === 3) && nuggets);
// то порядок операторов поменяется 
// вначале сравнение (кола=2 нет) или (фри=3 да)


// оператор не !
// console.log(!0); //true
// не ноль
// вначале аргумент к которому он применен он превращает в логический тип данных либо тру либо фолз и после этого оператор возвращает противоположное значение


//доделала урок 21 логические операторы 33 минуты (делала минимум 4 помидора)
//петриченко предлагает сделать в консоли задачи (делала минимум 2 помидора)

//console.log(NaN || 2 || undefined ); //2 так как не число или 2 или неопределенный единственное тру возвращается 2

// console.log( NaN && 2 && undefined ); //NaN так как не число и 2 и неопределенный - И запинается на первой лжи?

//console.log( 1 && 2 && 3 ); //3-1и2и3 вернуло последнее значение?

//console.log( !1 && 2 || !3 ); //false - 
//!-логическое отрицание НЕ 1 (пункт14)
//&&-логическое И (пункт4)
//||-логическое ИЛИ (пункт3)
//!-логическое отрицание НЕ 3 (пункт14)
//вначале читаем НЕ1 И 2 ИЛИ НЕ3 

//console.log( 25 || null && !3 ); //25
//25
//ИЛИ
//null-обозначение отсутствия значения (не ноль) 
//И
//НЕ3
//25 ИЛИ отсуствие значения И НЕ 3 = 25

//console.log( NaN || null || !3 || undefined || 5 );//5
//NaN - не число
//null-обозначение отстуствия значения (не ноль) (умышленное отстуствие значения)
//!3 = НЕ 3
//undefined -не определено значение (неожиданное отстуствие значения)
//5
//не число ИЛИ отсутствует значение ИЛИ не3 ИЛИ не определено значение ИЛИ 5 = 5
//у логического отрицания ! приоритет выше чем у ИЛИ ||

//console.log( NaN || null && !3 && undefined || 5 );//5
//&& логическое И приоритет выше чем у || лигическое ИЛИ
//у НЕ ! самый высокий приоритет
//отсутствие значение И не3 И не определено значение ИЛИ не число ИЛИ 5 = 5

//console.log( 5 === 5 && 3 > 1 || 5 );//true
//> больше пункт 9
//=== строгое равенство пункт 8
//&& логическое И пункт 4
//|| логическое ИЛИ пункт 3
//итого 5 строго равно 5 И 3 больше 1 ИЛИ 5 = true И true ИЛИ 5 = true

// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// if (hamburger === 3 && cola || fries === 3 && nuggets) {
// 	console.log('Done!');
// }
//Done! если гамбургеров 3 и 1 кола ИЛИ 3 фри и 1 наггетс = done

// let hamburger;
// const fries = NaN;
// const cola = 0;
// const nuggets = 2;

// if (hamburger || cola || fries === 3 || nuggets) {
// 	console.log('Done!');
// }
//Done! 
//=== строгое равенство пункт 8 (вначале фри = 3 false)
//|| логическое ИЛИ пункт 3 (потом 1 гамбургер фолз ИЛИ 1 кола фолз ИЛИ 3 фри фолз ИЛИ 1 наггетс тру - есть одно тру значит Done)
//переменная hamburger задана через let так как const требует какое-либо начальное значение, если const hamburger;-будет ошибка так как без значения там undefined - неожиданное отстутствие значения

// let hamburger;
// const fries = NaN;
// const cola = 0;
// const nuggets = 2;

// if (hamburger && cola || fries === 3 && nuggets) {
// 	console.log('Done!');
// }
//нет ответа
//=== строгое равенство пункт8 - вначале выполняется фри=3 это фолз
//&& логическое И пункт4 - потом выполняется гамбургер=1 и кола=1 это фолз, фри=3 и 1 наггетс это фолз
//|| логическое ИЛИ пункт3 - потом выполняется фолз или фолз

// const hamburger = 1;
// const fries = 1;
// const cola = 1;
// const nuggets = 2;

// if (hamburger && cola || fries === 3 && nuggets) {
// 	console.log('Done!');
// }
//Done


//урок 23 цикл в цикле и метки


// for (let i = 0; i < 3; i++) {
// 	console.log(i);
// 	for (let j = 0; j < 3; j++) {
// 		console.log(j);
// 	}
// }
// //0 - первый цикл
// //0 - второй цикл
// //1 - второй цикл
// //2 - второй цикл доходит до 2 меньше 3
// //1 - первый цикл 0+1=1
// //0 - начинается второй цикл
// //1 - второй цикл
// //2 - второй цикл доходит до 2 меньше 3
// //2 - начинается первый цикл 1+1=2 (первый цикл дает ответ в последний раз, i = 2 это меньше 3)
// //0 - начинается второй цикл с 0
// //1 - второй цикл
// //2 - второй цикл доходит до j= 2 это меньше 3, а первый цикл не начинается потому что он уже вернул ранее 2 меньше 3


// let result = '';
// const length = 7;

// for (let i = 1; i < length; i++) {

// 	for (let j = 0; j < i; j++) {
// 		result += '*';
// 	}

// 	result += '\n';
// }

// console.log(result);
// //*
// //**
// //***
// //****
// //*****
// //******


// first: for (let i = 0; i < 3; i++) {
// 	console.log(`First level: ${i}`);
// 	for (let j = 0; j < 3; j++) {
// 		console.log(`Second level: ${j}`);
// 		for (let k = 0; k < 3; k++) {
// 			if (k === 2) continue first;
// 			console.log(`Third level: ${k}`);
// 		}
// 	}
// }
// //First level: 0
// //Second level: 0
// //Third level: 0
// //Third level: 1
// //First level: 1
// //Second level: 0
// //Third level: 0
// //Third level: 1
// //First level: 2
// //Second level: 0
// //Third level: 0
// //Third level: 1
// //третий уровень доходит только до 1 меньше 2


// first: for (let i = 0; i < 3; i++) {
// 	console.log(`First level: ${i}`);
// 	for (let j = 0; j < 3; j++) {
// 		console.log(`Second level: ${j}`);
// 		for (let k = 0; k < 3; k++) {
// 			if (k === 2) break first;
// 			console.log(`Third level: ${k}`);
// 		}
// 	}
// }
// //First level: 0
// //Second level: 0
// //Third level: 0
// //Third level: 1


// //Задачи:


// //При помощи цикла выведите числа от 5 до 10 в консоль. 5 и 10 включительно. Цикл можно использовать любой
// for (let i = 5; i < 11; i++) {
// 	console.log(i);
// }
// //5
// //6
// //7
// //8
// //9
// //10


// //При помощи цикла for вывести числа от 20 до 10 в консоль. В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 13 - остановить весь цикл
// first: for (let i = 20; i >= 10; i--) {
// 	if (i === 13) break first;
// 	console.log(i);
// }
// //20
// //19
// //18
// //17
// //16
// //15
// //14


// //При помощи цикла for выведите чётные числа от 2 до 10 включительно
// for (let i = 2; i <= 10; i++) {
// 	if (i % 2 === 0) {
// 		console.log(i);
// 	}
// }
// //2
// //4
// //6
// //8
// //10


// //Перепишите цикл  for на вариант с while. Результат должен остаться точно таким же. Не создайте бесконечный цикл! Иначе браузер может зависнуть.
// //Цикл, который нужно переписать:
// for (let i = 2; i <= 16; i++) {
// 	if (i % 2 === 0) {
// 		continue;
// 	} else {
// 		console.log(i);
// 	}
// }
// //3
// //5
// //7
// //9
// //11
// //13
// //15
// let i = 2;
// while (i <= 16) {
// 	if (i % 2 === 0) {
// 		i++;
// 		continue;
// 	} else {
// 		console.log(i);
// 	}
// 	i++;
// }
// //3
// //5
// //7
// //9
// //11
// //13
// //15


// //Заполните массив цифрами от 5 до 10 включительно. Помните, что элементы массива можно сформировать так же, как и обращаться к ним: arr[0]
// const arrayOfNumbers = [];
// for (let i = 5; i < 11; i++) {
// 	arrayOfNumbers[i - 5] = i;
// }
// console.log(arrayOfNumbers);
// return arrayOfNumbers; 
// //parding error: 'return'outside of funstion eslint - добавила в .eslintrc.js в parserOptions - ecmaFeatures - globalReturn true
// //[ 5, 6, 7, 8, 9, 10 ]


//упражнение по написанию кода 4 * продвинутые задания на использование циклов и условий
//Задачи:


// //1. Заполните новый массив (result) числами из старого (arr). Количество элементов в массиве можно получить как arr.length, а к элементам обращаемся все так же: arr[0], arr[1] и тд. Должен получиться точно такой же массив
// // Место для первой задачи
// // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
// const arr = [3, 5, 8, 16, 20, 23, 50];
// const result = [];
// for (let i = 0; i < arr.length; i++) {
// 	result[i] = arr[i];
// }
// console.log(result);
// return result;
// //[
// //    3,  5,  8, 16,
// //   20, 23, 50
// // ]


// // 2.Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к ней было добавлено " - done".
// // Для определения типа данных используйте typeof();
// // Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]
// // Место для второй задачи
// // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
// const data = [5, 10, 'Shopping', 20, 'Homework'];
// for (let i = 0; i < data.length; i++) {
// 	if (typeof(data[i]) === 'number') {
// 		data[i] = data[i] * 2;
// 	} else if (typeof(data[i]) === 'string') {
// 		data[i] = `${data[i]} - done`;
// 	}
// }
// console.log(data); 
// return data;
// //[ 10, 20, 'Shopping - done', 40, 'Homework - done' ]


// //3. Разверните массив data наоборот при помощи цикла и запишите данные в массив result. 
// //Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
// // Место для третьей задачи
// // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
// const data = [5, 10, 'Shopping', 20, 'Homework'];
// const result = [];

// for (let i = 1; i <= data.length; i++) {
// 	result[i - 1] = data[data.length - i];
// }
    
// console.log(result);
// return result;
// //[ 'Homework', 20, 'Shopping', 10, 5 ]


// ///упражнение по написанию кода 5 ** задача на формирование фигуры
// //Сейчас вам необходимо написать код, который при помощи звездочек (*) в консоли нарисует вот такую фигуру:
// //     *
// //    ***
// //   *****
// //  *******
// // *********
// //***********
// //Подсказка: в конце фигуры есть перенос строки \n, который тоже учитывается в тестах. 
// //В КОНЦЕ КАЖДОЙ СТРОКИ НЕТ ПРОБЕЛОВ, ТОЛЬКО ПЕРЕНОС
// // Проверяется именно переменная result, формируйте строку в ней
// const lines = 5;
// let result = '';
// for (let i = 0; i <= lines; i++) {
// 	for (let j = 0; j < lines - i; j++) {
// 		result += ' ';
// 	}
// 	for (let k = 0; k < 2 * i + 1; k++) {
// 		result += '*';
// 	}
// 	result += '\n';
// }
// console.log(result);


// const usdCurr = 28;
// const eurCurr = 32;

// function convert(amount, curr) {
//     console.log(curr * amount);
// }

// convert(500, usdCurr); //500*28=14000
// convert(500, eurCurr); //500*32=16000

// // Упражнение по написанию кода 7:(*) Продвинутые задания на использование функций

// //Задачи:

// //1) Создайте функцию, которая будет вычислять объем и площадь полной поверхности куба (тоже базовая математика, иногда используется в создании анимаций). Эта функция принимает в себя целое число со значением длины ребра куба. Ответ выведите в формате строки, который изображен в примерах.
// //Если в функцию попал неправильный аргумент или вычислить значения невозможно - вернуть строку "При вычислении произошла ошибка"
// //НЕ ИСПОЛЬЗУЙТЕ ОПЕРАТОР СТЕПЕНИ ** - в онлайн среде браузера он не работает и тесты будут ломаться. Это из-за того, что этот оператор из более нового стандарта, чем тут доступен.
// //Примеры:
// //calculateVolumeAndArea(5)  => 'Объем куба: 125, площадь всей поверхности: 150'
// //calculateVolumeAndArea(15)  => 'Объем куба: 3375, площадь всей поверхности: 1350'
// //calculateVolumeAndArea(15.5)  => 'При вычислении произошла ошибка'
// //calculateVolumeAndArea('15')  => 'При вычислении произошла ошибка'
// //calculateVolumeAndArea(-15)  => 'При вычислении произошла ошибка'

// function calculateVolumeAndArea(length) {
//     if (typeof (length) !== 'number' || length < 0 || !Number.isInteger(length)) {
//         return "При вычислении произошла ошибка";
//     }

//     let volume = 0;
//     let area = 0;

//     volume = length * length * length; 
//     //length ** 3 - тоже самое, ** - оператор степени, но онлайн редактор его не понимает
//     area = 6 * (length * length);

//     return `Объем куба: ${volume}, площадь всей поверхности: ${area}`;
// }

// calculateVolumeAndArea(5);
// calculateVolumeAndArea(15);
// calculateVolumeAndArea(15.5);
// calculateVolumeAndArea('15');
// calculateVolumeAndArea(-15);

// //Expected 'Объем куба: 0, площадь всей поверхности: 0' to equal 'Объем куба: 125, площадь всей поверхности: 150'.
// //Expected-Ожидал, to equal-в равной
// //забыла length в скобках function calculateVolumeAndArea(length) {

// //2) Напишите функцию, которая будет определять номер купе по переданному ей номеру места. 
// //Функция принимает только целое число от 1 до 36.
// //Если переданный аргумент не число, отрицательное или дробное - возвращается сообщение: "Ошибка. Проверьте правильность введенного номера места"
// //Если число 0 или больше 36, то сообщение: "Таких мест в вагоне не существует"
// //Пример:
// //getCoupeNumber(33)  => 9
// //getCoupeNumber(7)  => 2
// //getCoupeNumber(300)  => "Таких мест в вагоне не существует"
// //getCoupeNumber(0)  => "Таких мест в вагоне не существует"
// //getCoupeNumber(7.7)  => "Ошибка. Проверьте правильность введенного номера места"
// //getCoupeNumber(-10)  => "Ошибка. Проверьте правильность введенного номера места"
// //getCoupeNumber('Hello')  => "Ошибка. Проверьте правильность введенного номера места"

// function getCoupeNumber(seatNumber) {
//     if (typeof (seatNumber) !== 'number' || seatNumber < 0 || !Number.isInteger(seatNumber)) {
//         return "Ошибка. Проверьте правильность введенного номера места";
//     }

//     if (seatNumber === 0 || seatNumber > 36) {
//         return "Таких мест в вагоне не существует";
//     }

//     return Math.ceil(seatNumber / 4);
// }

// getCoupeNumber(33);
// //typeof (оператор возвращает строку указывающую тип операнда 42-number, 'blubber'-string, true-boolean, undeclaredVariable-undefined)
// //sInteger() определяет, является ли значение целым числом.

// //создаю функцию getCoupeNumber с аргументом seatNumber
// //если тип данных аргумента не номер И аргумент меньше нуля И аргумент НЕ является целым числом - ТОГДА ОШИБКА
// //если аргумент строго равно 0 И больше 36 - НЕ СУЩЕСТВУЕТ
// //вернуть округление дробного числа до целого всегда в большую сторону значение аргумента деленное на 4 это будет номер купе
// //вызов функции


// Упражнение по написанию кода 8: (*) Продвинутые задания на использование функций
//Задачи:
// //1) Создайте функцию, которая принимает в себя целое число минут и возвращает время в нужном формате строки. (Смотри пример). Обратите внимание на окончание слова "час" - оно меняется в зависимости от цифры. Если вместо аргумента приходит не число, дробное или отрицательное число - функция возвращает строку "Ошибка, проверьте данные"
// //Внимание! Давайте пока ограничимся максимум 600ю минутами (10 часов). Так как проверки на большие числа будут раздувать код (33 часа, 31 час, 11 часов и тд). Этого будет достаточно и код будет проверять именно этот промежуток (1 - 10 часов). Но вы можете реализовать и полный скрипт, он тоже должен проходить тесты.
// //Пример:
// //getTimeFromMinutes(150) => "Это 2 часа и 30 минут"
// //getTimeFromMinutes(50) => "Это 0 часов и 50 минут"
// //getTimeFromMinutes(0) => "Это 0 часов и 0 минут"
// //getTimeFromMinutes(-150) => "Ошибка, проверьте данные"


// function getTimeFromMinutes(minutesTotal) {
//     if (typeof(minutesTotal) !== 'number' || minutesTotal < 0 || !Number.isInteger(minutesTotal)) {
//         return "Ошибка, проверьте данные";
//     }

//     const hours = Math.floor(minutesTotal / 60);
//     const minutes = minutesTotal % 60;

//     let hoursStr = '';

//     switch (hours) {
//         case 0:
//             hoursStr = 'часов';
//             break;
//         case 1:
//             hoursStr = 'час';
//             break;
//         case 2:
//         case 3:
//         case 4:
//             hoursStr = 'часа';
//             break;
//         default:
//             hoursStr = 'часов';
//     }

//     return `Это ${hours} ${hoursStr} и ${minutes} минут`;
// }

// console.log(getTimeFromMinutes(180)); //Это 3 часа и 0 минут



// //2) Напишите функцию, которая принимает в себя 4 числа и возвращает самое большее из них. Если один из аргументов не является числом или их меньше 4 - возвращается 0. Дробные числа разрешены.
// //Пример:
// //findMaxNumber(1, 5, 6.6, 11); =>  11
// //findMaxNumber(1, 5, '6', '10');  =>  0

// function findMaxNumber(a, b, c, d) {
//     if (typeof(a) !== 'number' ||
//         typeof(b) !== 'number' ||
//         typeof(c) !== 'number' ||
//         typeof(d) !== 'number') {
//         return 0;
//     } else {
//         return Math.max(a, b, c, d);
//     }
// }

// console.log(findMaxNumber(1, 5, 6.6, 10.5));//10.5
// console.log(findMaxNumber(1, 5, '6', '10'));//0



// //(**) Задача с собеседований на числа Фибоначчи
// //числа Фибоначчи, где первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. 
// //решение БЕЗ рекурсии
// //Задача:
// //Создайте функцию, которая будет принимать в себя один аргумент-целое положительное число. Она должна возвращать строку, в которой будут через пробел выведены числа Фибоначчи. Причем, их количество должно быть равно переданному аргументу. Если переданный аргумент не число - вернуть пустую строку. Решать без применения рекурсии.
// //Пример:
// //fib(4) => ''0 1 1 2"
// //fib(7) => ''0 1 1 2 3 5 8"
// //fib('7') => ''"
// //fib(1) => "0"
// //fib(0) => ''"

// function fib(num) {
//     if (typeof(num) !== 'number' || num <= 0 || !Number.isInteger(num)) {
//         return "";
//     }

//     let result = '';
//     let first = 0;
//     let second = 1;

//     for (let i = 0; i < num; i++) {
//         if (i + 1 === num) {
//             result += `${first}`; //без пробела вконце
//         } else {
//             result += `${first} `;//с пробелом вконце
//         }

//         let third = first + second;
//         first = second;
//         second = third;
//     }

//     return result;
// }

// console.log(fib(5));//0 1 1 2 3



// //l.31 callback-функции

// function first() {
//     //Do something
//     setTimeout(function() {
//         console.log(1);
//     }, 500);
// }

// function second() {
//     console.log(2);
// }

// first();
// second();
// //2
// //1
// //то есть вначале выполняется вторая функция, а потом задержка на 500миллисекунд/1000=0,5секунд и выполняется первая функция, то есть запускаются одна за другой, но результат могут отдать в разное время
// //колбэк - функция которая должна быть выполнена после того как другая функция завершила свое выполнение 

// function learnJS(lang, callback) {
//     console.log(`Я учу: ${lang}`);
//     callback();
// }

// learnJS('JavaScript', function() {
//     console.log('Я прошла этот урок!');
// });
// // учу: JavaScript
// //Я прошла этот урок!



// function learnJS(lang, callback) {
//     console.log(`Я учу: ${lang}`);
//     callback();
// }

// function done() {
//     console.log('Я прошла этот урок!!');
// }

// learnJS('JavaScript', done);
// //Я учу: JavaScript
// //Я прошла этот урок!!



//l.32 Объекты, деструктуризация объектов (ES6)

// const options = {
//     name: 'test',
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'
//     }
// };

//console.log(options.name);//test

// delete options.name; //удалить свойство name объекта options
// console.log(options); //{ width: 1024, height: 1024, colors: { border: 'black', bg: 'red' } }

//перебрать все свойства объекта конструкция фор ин
//ключевое слово for в круглых кнопках настроить наш цикл здесь мы укажем в какой объекте мы будем перебирать эти свойства и как каждое свойство нам назвать общее слово key ключ (ключ-значение) чтобы перебирать ключи переменная key и будем копаться внутри options раскрываем конструкцию и задаем что будет выполняться цикл будет работать столько раз сколько свойств внутри объекта выводим в консоль конструкцию свойство перебираем каждое отдельное свойство key имеет значение что за значение находится в свойстве key - пользуемся конструкцией работаем в объете опшинс значение этого ключа который перебирается в этом повторении цикла
//`` бэктики

//for (let key in options) {
//    console.log(`Свойство ${key} имеет значение ${options[key]}`);
//}
//ответ: 
//Свойство name имеет значение test
//Свойство width имеет значение 1024
//Свойство height имеет значение 1024
//Свойство colors имеет значение [object Object]

//свойство for (let key of options) {} - для объектов работать не будет
//[object Object]- сейчас все значения выводим в качестве строк, но одно из свойств объекта тоже является объектом, когда код натыкается на такой объем он не может его превратить в строку и в вывод выводит такую структуру (строковое представление объекта) не ошибка, а объект который код не может превратить в строчку



// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//         }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//     }
// }
// // console.log(options["colors"]["border"]);//black
// //элз - если ключ наш не будет объектом то мы просто выводим так как это было раньше
// //ответ:
// // Свойство name имеет значение test
// // Свойство width имеет значение 1024
// // Свойство height имеет значение 1024
// // Свойство border имеет значение black
// // Свойство bg имеет значение red


// let counter = 0;
// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//             counter++;
//         }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     }
// }
// console.log(counter);
// //посчитаем количество свойств с помощью цикла
// //ответ:
// //Свойство name имеет значение test
// //Свойство width имеет значение 1024
// //Свойство height имеет значение 1024
// //Свойство border имеет значение black
// //Свойство bg имеет значение red
// //5-потому что считывает 2 уровень вложенности (name, width, height, border, bd) - и внутри for есть counter и внутри else, если оставить только в else - будет считать только первый уровень name, width, height, colors и выдаст результат - 4



// let counter = 0;
// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//         }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     }
// }
// console.log(counter);
// //ответ 3
// //что-то пошло не так, программа начала считать: name width height - уткнулась в объект и пошла по другому разветвлению условия if  выдала результат

// //классический способ узнать количество ключей
// let counter = 0;
// for (let key in options) {
//     counter++;
// }
// console.log(counter);
// //ответ 4
// //но это не удобно, есть метод:

// console.log(Object.keys(options));
// //[ 'name', 'width', 'height', 'colors' ] //получаем массив с ключами
// //у массива есть свойство length-узнать количество элементов


// console.log(Object.keys(options).length);
// //4



// //методы это действия которые умеет совершать наш объект
// const options = {
//     name: 'test',
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'
//     },
//     makeTest: function() {
//         console.log("Test");
//     }
// };
// options.makeTest();
// //Test

//объекты - структуры которые могут сохранять в себе любые типы данных в формате ключ-значение, они также могут быть вложенные объекты в объекты, массивы в объекты и тд. чтобы их перебрать можем использовать конструкцию фор ин и делать что угодно с ключами key и значениями. получать свойства можем через точку или квадратные скобки. у объектов бывают встроенные методы и встроенные свойства, чтобы объект что-то умел мы можем внутрь него записывать функции и таким образом создавать методы нашего объекта. свойства акцессоры - гэт и сэт, деструктуризация объекта

// //деструктуризация объекта - достучаться до вложенных свойств:
// const {border, bg} = options.colors;
// //переменная {те переменные которые хочу вытащить} присвоить ту структура из которой хочу сделать более мелкие кусочки из свойства option colors
// console.log(border);//black

//джаваскрипт считается объектно-ориентированным языком и все сущности которые в нем есть сводятся к объектам. но правильнее считать прототипно-ориентрованным



// let number = 1;
// //console.log(--number);//0-отдельно
// //console.log(number++);//1-отдельно
// //console.log(++number);//2-отдельно

// console.log(--number);//0-подряд
// console.log(number++);//0-подряд
// console.log(++number);//2-подряд


//урок 33. Массивы и псевдомассивы

//const arr = [1, 2, 3, 6, 8]; //массив набор чисел

//arr.pop();//[ 1, 2, 3, 6 ] метод удаляет последний элемент массива
//arr.push(10);//[ 1, 2, 3, 6, 8, 10 ] метод добавляет элемент (в скобках что добавить)
//console.log(arr);
//чтобы добавить в начало элемент не достаточно его вписать, еще и у последнующих ранее вставленных элементов меняются индексы 0=1, 1=2, 2=3, 3=6, 4=8

// for (let i = 0; i < arr.length; i++) {
//     console.log(arr[i]);
// }
// //1
// //2
// //3
// //6
// //8


// for (let value of arr) {
//     console.log(value);
// }
// //1
// //2
// //3
// //6
// //8
// //конструкция for of работает только с массиво подобными сущностями, с помощью фор оф нельзя перебрать объекты, но можно: массив, строку, псевдомассивы, мэп и сэт.
//можно использовать break, continue


//console.log(arr.length);//5-длина массива
// arr[99] = 0;
// console.log(arr.length);//100 отому что свойство лэнг происходит от последнего индекса плюс 1
// console.log(arr); //[ 1, 2, 3, 6, 8, <94 empty items>, 0 ] //нарушение, элементы лежат не по порядку



// arr.forEach(function(item, i, arr) {
//     console.log(`${i}: ${item} внутри массива ${arr}`);
// });
// //0: 1 внутри массива 1,2,3,6,8
// //1: 2 внутри массива 1,2,3,6,8
// //2: 3 внутри массива 1,2,3,6,8
// //3: 6 внутри массива 1,2,3,6,8
// //4: 8 внутри массива 1,2,3,6,8
// //метод позволяет отдельно задать класс разным элементам
// //break, continue не работают



// const str = prompt("", "");
// const products = str.split(", ");
// console.log(products);
// //промпт в консоли вскода не работает, только всплывающими окнами в браузере
// //всплывает окно, в нем я ввожу товары через запятую: qqq, www, eee окей и открываю консоль которая возвращает массив array 
// //0: "qqq"
// //1: "www"
// //2: "eee"


// //метод join объединение элементов в массив и разделитель в скобочках с помощью которого будут выводиться элементы
// const str = prompt("", "");
// const products = str.split(", ");
// console.log(products.join('; '));
// //в всплывающем на странице окне ввожу www, www, rrr, vvv
// //в консоли мне отвечают: www; www; rrr; vvv

//метод сорт
// const str = prompt("", "");
// const products = str.stlit(", ");
// products.sort();
// console.log(products.join('; '));
// //в всплывающем окне на странице ввожу qqq, aaa, bbb нажимаю окей и в консоли:
// // aaa; bbb; qqq
// //строчные элементы сортируются по алфавиту

// const arra = [2, 13, 26, 8, 10];
// arra.sort();
// console.log(arra);
// //[ 10, 13, 2, 26, 8 ]
// //очень странная сортировка, каждое число которое начинается с единички встало на первое место 10 и 13 по первому символу равны дальше 0 и 3 - 0 идет перед 3

// const arra = [2, 13, 26, 8, 10];
// arra.sort(compareNum);
// console.log(arra);

// function compareNum(a, b) {
//     return a - b;
// }
// //[ 2, 8, 10, 13, 26 ]




//урок 35 передача по ссылке и по значению, spread оператор (ES6-ES9)

// let a = 5,
//     b = a;
// b = b + 5;
// console.log(b);//10
// console.log(a);//5



// const obj = {
//     a: 5,
//     b: 1
// };
// const copy = obj;//ссылку
// copy.a = 10;
// console.log(copy);//{ a: 10, b: 1 }
// console.log(obj);//{ a: 10, b: 1 }
// //не получилось. а как копировать объект?



// function copy(mainObj) {
//     let objCopy = {};
//     let key;
//     for (key in mainObj) {
//         objCopy[key] = mainObj[key];
//     }
//     return objCopy;
// }
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// const newNumbers = copy(numbers);
// newNumbers.a = 10;
// console.log(newNumbers);//{ a: 10, b: 5, c: { x: 7, y: 4 } }
// console.log(numbers);//{ a: 2, b: 5, c: { x: 7, y: 4 } }
//a - поменялось



// function copy(mainObj) {
//     let objCopy = {};
//     let key;
//     for (key in mainObj) {
//         objCopy[key] = mainObj[key];
//     }
//     return objCopy;
// }
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// const newNumbers = copy(numbers);
// newNumbers.a = 10;
// newNumbers.c.x = 10;
// console.log(newNumbers);//{ a: 10, b: 5, c: { x: 10, y: 4 } }
// console.log(numbers);//{ a: 2, b: 5, c: { x: 10, y: 4 } }
// //a - поменялось
// //x внутри c - перезаписалось в старом и новом при том что в старом было записано 7
// //когда копируем объекты есть глубокие и поверхностные копии объектов
// //сейчас создали поверхностную копию
// //потом научимся создавать глубокую копию чтобы изменять скопированный объект



// //Метод Object. assign() используется для копирования свойств из одного или нескольких объектов в объект, переданный в метод первым аргументом.
// //соединить два объекта в один
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// const add = {
//     d: 17,
//     e: 20
// };
// // console.log(Object.assign(numbers, add));
// // //{ a: 2, b: 5, c: { x: 7, y: 4 }, d: 17, e: 20 }
// const clone = Object.assign({}, add);
// clone.d = 33;
// // console.log(add);//{ d: 17, e: 20 }
// // console.log(clone);//{ d: 33, e: 20 }



// const oldArray = ['a', 'b', 'c'];
// const newArray = oldArray.slice();
// newArray[1] = 'asdfghj';
// console.log(newArray);//[ 'a', 'asdfghj', 'c' ]
// console.log(oldArray);//[ 'a', 'b', 'c' ]



// spread оператор или оператор разворота
//1 вариант:
// const video = ['youtube', 'vimeo', 'rutube'],
//       blogs = ['wordpress', 'livejournal', 'blogger'],
//       internet = [...video, ...blogs, 'vk', 'facebook'];
// console.log(internet);
// //[
// //    'youtube',
// //    'vimeo',
// //    'rutube',
// //    'wordpress',
// //    'livejournal',
// //    'blogger',
// //    'vk',
// //    'facebook'
// //  ]
//2 вариант:
// function log(a, b, c) {
//     console.log(a);
//     console.log(b);
//     console.log(c);
// }
// const num = [2, 5, 7];
// log(...num);
// //2
// //5
// //7
//3 вариант:
// const array = ["a", "b"];
// const newArray = [...array];
// console.log(array);//[ 'a', 'b' ]
// console.log(newArray);//[ 'a', 'b' ]
//4 вариант:
// const objQ = {
//     one: 1,
//     two: 2
// };
// const newObjQ = {...objQ};
// console.log(objQ);//{ one: 1, two: 2 }
// console.log(newObjQ);//{ one: 1, two: 2 }



// //упражнение по написанию кода 10: задачи на работу с объектами
// //Задачи:
// //1) Напишите функцию showExperience, которая будет принимать в себя объект со всеми данными и возвращать строку с опытом. 
// //Пример: showExperience(personalPlanPeter) => '1 month'
// //желательно использовать деструктуризацию, но не обязательно
// //2) Напишите функцию showProgrammingLangs, которая будет принимать в себя объект со всеми данными и возвращать строку в нужном виде.
// //Пример: showProgrammingLangs(personalPlanPeter)  => "Язык js изучен на 20% Язык php изучен на 10%"
// //Причем функция должна работать вне зависимости от количества языков. Если ни один не указан, то возвращается пустая строка. Для переноса строки используется \n в конце строки.
// //3) Создайте метод showAgeAndLangs внутри объекта personalPlanPeter. При его вызове метод будет принимать в себя объект и возвращать строку в нужном виде.
// //Пример: personalPlanPeter.showAgeAndLangs(personalPlanPeter) => 'Мне 29 и я владею языками: RU ENG'
// //Заметьте, что возраст и языки подставляются автоматически из объекта, а языки всегда в верхнем регистре (большими буквами). Если данные в объекте поменяются, то и сообщение тоже изменится.

// const personalPlanPeter = {
//     name: "Peter",
//     age: "29",
//     skills: {
//         languages: ['ru', 'eng'],
//         programmingLangs: {
//             js: '20%',
//             php: '10%'
//         },
//         exp: '1 month'
//     },
//     showAgeAndLangs: function(plan) {
//         const {age} = plan;
//         const {languages} = plan.skills;
//         let str = `Мне ${age} и я владею языками: `;

//         languages.forEach(function(lang) {
//             str += `${lang.toUpperCase()} `;
//         });

//         return str;
//     }
// };

// console.log(personalPlanPeter.showAgeAndLangs(personalPlanPeter)); //Мне 29 и я владею языками: RU ENG 

// function showExperience(plan) {
//     const {exp} = plan.skills;
//     return exp;
// }

// console.log(showExperience(personalPlanPeter)); //1 month

// function showProgrammingLangs(plan) {
//     let str = '';
//     const {programmingLangs} = plan.skills;
//     for (let key in programmingLangs) {
//         str += `Язык ${key} изучен на ${programmingLangs[key]}\n`
//     }
//     return str;
// }

// console.log(showProgrammingLangs(personalPlanPeter));
// //Язык js изучен на 20%
// //Язык php изучен на 10%



//упражнение по написанию кода 11: задачи на работу с массивами
//Задачи:
// //1) Напишите функцию showFamily, которая будет принимать в себя массив строк и возвращать сообщение в нужном формате.
// //showFamily(family)  => 'Семья состоит из: Peter Ann Alex Linda'
// //Имена подставляются автоматически из массива. Если массив пустой, то выводится сообщение 'Семья пуста'
// const family = ['Peter', 'Ann', 'Alex', 'Linda'];
// function showFamily(arr) {
//     let str = '';
//     arr.length === 0 ? str = 'Семья пуста' : str = 'Семья состоит из: ';
//     arr.forEach(member => {
//         str += `${member} `
//     });
//     return str;
// }
// console.log(showFamily(family));//Семья состоит из: Peter Ann Alex Linda 


// //2) напишите функцию standardizeStrings, которая будет принимать в себя массив строк и будет выводить в консоль эти строки в нижнем регистре.
// //Пример:
// //standardizeStrings(favoriteCities)  выведет в консоль
// //lisbon
// //rome
// //milan
// //dublin
// const favoriteCities = ['liSBon', 'ROME', 'miLan', 'Dublin'];
// function standardizeStrings(arr) {
//     arr.forEach(city => {
//         console.log(city.toLowerCase())
//     })
// }
// console.log(standardizeStrings(favoriteCities));
// //lisbon
// //rome
// //milan
// //dublin
// //undefined



// упражнение по написанию кода 12 задачи на работу с массивами часть 2
// 3) Задача с собеседований. Напишите функцию reverse, которая принимает в себя строку и возвращает эту строку в обратном порядке.
// Пример:
// const someString = 'This is some strange string';
// reverse(someString) => 'gnirts egnarts emos si sihT'
// Функцию можно применить к любой строке. Если в функцию приходит не строка - вернуть сообщение "Ошибка!"
// Метод reverse() на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.

// //Оптимальный вариант решения:
// const someString = 'This is some strange string';
// function reverse(str) {
//     if (typeof(str) !== 'string') {
//         return "Ошибка!";
//     }
//     return str.split('').reverse().join('');
// }
// console.log(reverse(someString));//gnirts egnarts emos si sihT

// //решение при помощи цикла:
// const someString = 'This is some strange string';
// function reverse(str) {
//     let newStr = '';
//     for (let i = str.length - 1; i >= 0; i--) {
//         newStr += str[i];
//     }
//     return newStr
// }
// console.log(reverse(someString));//gnirts egnarts emos si sihT



// 4) Представьте такую реальную ситуацию. У вас есть банкомат, который выдает деньги из двух разных банков в разных валютах. Один банк основной с базовыми валютами, второй дополнительный с прочими валютами:
// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
// Вам нужно создать главную функцию банкомата availableCurr, которая принимает два аргумента: первый - это массив со всеми доступными валютами из двух банков сразу (сейчас представим, что они не могут повторяться), второй - необязательный аргумент, который указывает ту валюту, которая сейчас закончилась в банкомате. Если массив в первом аргументе пустой - то функция возвращает строку 'Нет доступных валют'. Функция возвращает строку в нужном виде.
// Пример:
// availableCurr(['UAH', 'RUB', 'CNY'], 'CNY')
// Вернет строку:
// Доступные валюты:
// UAH
// RUB
// Заметьте:
// - CNY (юань) исчез из списка валют, значит такая валюта закончилась
// - После валюты: стоит перенос строки \n, и после каждой валюты тоже. Это важно для тестов
// - Данные для первого аргумента должны приходить сразу из двух банков, причем сначала baseCurrencies, потом additionalCurrencies по порядку

// //оптимальное решение:
// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
// function availableCurr(arr, missingCurr) {
//     let str = '';
//     arr.length === 0 ? str = 'Нет доступных валют' : str = 'Доступные валюты:\n';
//     arr.forEach(function(curr, i) {
//         if (curr != missingCurr) {
//             str += `${curr}\n`;
//         }
//     });
//     return str;
// }
// console.log(availableCurr([...baseCurrencies, ...additionalCurrencies], 'CNY'))
// //Доступные валюты:
// //USD
// //EUR
// //UAH
// //RUB

// //с помощью цикла фор
// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
// function availableCurr(arr, missingCurr) {
//     let str = '';
//     arr.length === 0 ? str = 'Нет доступных валют' : str = 'Доступные валюты:\n';
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] === missingCurr) {
//             continue;
//         }
//         str += `${arr[i]}\n`;
//     }
//     return str;
// }
// console.log(availableCurr([...baseCurrencies, ...additionalCurrencies], 'CNY'));
// //Доступные валюты:
// //USD
// //EUR
// //UAH
// //RUB



// //упражнение по написанию кода 13: (*) Продвинутая задача на работу с объектами и массивами
// //Задача:
// //У вас есть небольшой кусочек данных о торговом центре, которые записаны в объекте shoppingMallData. Они содержат массив с данными о магазинах, где указана длина и ширина помещения; высоту помещения; стоимость отопления за 1 кубический метр и бюджет на оплату отопления за месяц.
// //Основная задача - это написать функцию isBudgetEnough, которая будет возвращать строку. Если бюджета хватает для отопления всего объема торгового центра - выводится 'Бюджета достаточно', если нет - 'Бюджета недостаточно'. И все 
// //Но эта задача содержит несколько подзадач внутри:
// //- вычисление общей площади всех магазинов, которая вычисляется как длина магазина, умноженная на его ширину;
// //- вычисление общего объема торгового центра, так как цена отопления указана в кубических метрах;
// //- определение того, хватает ли бюджета на оплату такого объема;
// //- все числа идут без единиц измерения для упрощения, просто цифры и все;
// //- функция должна продолжать работать, даже если изменяется количество магазинов, высота, бюджет или подставляется вообще другой объект.

// const shoppingMallData = {
//     shops: [
//         {
//             width: 10,
//             length: 5
//         },
//         {
//             width: 15,
//             length: 7
//         },
//         {
//             width: 20,
//             length: 5
//         },
//         {
//             width: 8,
//             length: 10
//         }
//     ],
//     height: 5,
//     moneyPer1m3: 30,
//     budget: 50000
// }

// function isBudgetEnough(data) {
//     let square = 0;
//     let volume = 0;

//     data.shops.forEach(shop => {
//         square += shop.width * shop.length;
//     });

//     volume = data.height * square;

//     if (data.budget - (volume * data.moneyPer1m3) >= 0) {
//         return 'Бюджета достаточно';
//     } else {
//         return 'Бюджета недостаточно';
//     }
// }

// console.log(isBudgetEnough(shoppingMallData));//Бюджета недостаточно

// //есть объект shoppingMallData
// //в массиве данные: ширина и длина помещения (разные)
// //высота помещения (одинаковая у всех)
// //стоимость отопления за метр
// //бюджет на всех

// //надо посчитать: достаточно или нет бюджета

// //длина*ширина=площадь магазина и все сложить
// //(10*5)+(15*7)+(20*5)+(8*10)=335 это square
// //volume=5*335=1675
// //плата: 1675*30=50250 - бюджет 50000 т.е. бюджета не достаточно

// //объявляю переменную площадь
// //объявляю переменную объем

// //последовательно перебрать все элементы массива и умножить ширину на длину += присваивание со сложением

// //чтобы получить объем умножаю высоту на площадь

// //если (бюджет - (объем*цену)) больше или равно 0 значит бюджета достаточно, если меньше 0 - бюджета не достаточно

// //вызов функции



// //упражнение по написанию кода 14: (*) продвинутая задача на работу с объектами и массивами
// //Задача:
// //У вас есть список учеников, которые хотят поиграть в игру:
// //const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];
// //Но команд может быть только 3 по 3 человека. Напишите функцию sortStudentsByGroups, которая принимает в себя массив строк.
// //Внутри она сначала сортирует имена по алфавиту. 
// //Затем распределяет учеников по 3 человека в 3 группы по алфавитному порядку.
// //Эти группы должны быть массивами. 
// //Как итог, функция возвращает новый массив с тремя командами и строкой как 4й элемент.
// //Пример:
// //sortStudentsByGroups(students)  =>
// //[
// //  [ 'Andrew', 'Ann', 'Bernard' ],
// //  [ 'Cris', 'Josh', 'Mark' ],
// //  [ 'Peter', 'Sam', 'Sandra' ],
// //  'Оставшиеся студенты: Takesi'
// //]
// //Если убрать одно студента из списка, то результат будет:
// //[
// //    [ 'Andrew', 'Ann', 'Bernard' ],
// //    [ 'Cris', 'Josh', 'Mark' ],
// //    [ 'Peter', 'Sam', 'Sandra' ],
// //    'Оставшиеся студенты: -'
// //  ]
// //А если добавить одного, то:
// //  [
// //    [ 'Andrew', 'Ann', 'Bernard' ],
// //    [ 'Cris', 'Josh', 'Mark' ],
// //    [ 'Peter', 'Sam', 'Sandra' ],
// //    'Оставшиеся студенты: Takesi, Somebody'
// //  ]
// //То есть, меняется содержимое строки. Все оставшиеся ученики попадают туда.

// //метод sort - сортировка содержимого в вызванном массиве
// //rest остальные
// //метод push добавляет неограниченное количество элементов в конец массива - исходный массив меняется
// //метод join объединяет элементы массива в строку с указанным разделителем (он будет вставлен между элементами массива)


// const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];
// function sortStudentsByGroups(arr) {
//     arr.sort();
//     const a = [], b = [], c = [], rest = [];

//     for (let i = 0; i < arr.length; i++) {
//         if (i < 3) {
//             a.push(arr[i]);
//         } else if (i < 6) {
//             b.push(arr[i]);
//         } else if (i < 9) {
//             c.push(arr[i]);
//         } else {
//             rest.push(arr[i]);
//         }
//     }
//     return [a,b,c, `Оставшиеся студенты: ${rest.length === 0 ? '-' : rest.join(', ')}`]
// }
// console.log(sortStudentsByGroups(students));
// //ответ:
// //[
// //    [ 'Andrew', 'Ann', 'Bernard' ],
// //    [ 'Cris', 'Josh', 'Mark' ],
// //    [ 'Peter', 'Sam', 'Sandra' ],
// //    'Оставшиеся студенты: Takesi'
// //  ]



// //урок 39 Динамическая типизация в JS
// //(превращение одних типов данных в другие)

// // To String - превратить в строку

// //1

// console.log(typeof(String(null)));//string

// console.log(String(null)); //null

// console.log(typeof(String(4)));//string

// //2 способ конкатенация сцепление

// console.log(typeof(5 + ''));//string

// console.log(typeof(null + ''));//string


// const num = 5;
// console.log("https://vk.com/catalog" + num); //https://vk.com/catalog5


// const fontSize = 26 + 'px';
// console.log(fontSize);//26px


// // To Number

// //1
// console.log(typeof(Number('4')));//number

// //2 способ унарный плюс
// console.log(typeof(+'5'));//number

// //3
// console.log(typeof(parseInt("15px", 10)));//number


// let answ = +prompt("Hello", "");//работает только в браузере

// // To boolean

// //пустота-false: 0, '', null, undefined, NaN

// //1 способ нативный
// let switcher = null;

// if (switcher) {
//     console.log('Working...');
// }//null=false ответа нет

// switcher = 1;

// if (switcher) {
//     console.log('Working...');
// }//1=true ответ: Working...

// //2 
// console.log(typeof(Boolean('4')));//boolean

// //3 - два знака отрицания !!
// console.log(typeof(!!"44444"));//boolean



// 41. Задачи с собеседований на понимание основ

// //1) Какое будет выведено значение: let x = 5; alert( x++ );
// let x = 5;
// //alert( x++ ); //5
// //alert( ++x ); //6


// //2) Чему равно такое выражение: //[ ] + false - null + true
// console.log([] + false);//false
// console.log([] + false - null);//NaN
// console.log([] + false - null + true);//NaN


// //3) Что выведет этот код: let y = 1; let x = y = 2; alert(x); 
// let y = 1;
// let x = y = 2;
// alert(x);//2


// //4) Чему равна сумма [ ] + 1 + 2
// console.log([] + 1 + 2);//12 -так как впереди массив возвращает строку


// //5) Что выведет этот код alert( "1"[0] )
// alert( "1"[0] );//1 -строка 1 индекс 0 выводит первый символ строки


// //6) Чему равно 
// //2 && 1 && null && 0 && undefined 

// //логическое И (&&) ЗАПИНАЕТСЯ НА ЛЖИ - ВЫШЕ ПРИОРИТЕТ ЧЕМ У ИЛИ
// //логическое ИЛИ (||) ЗАПИНАЕТСЯ НА ПРАВДЕ - НИЖЕ ПРИОРИТЕТ ЧЕМ У И

// console.log(2 && 1);//1
// console.log(1 && null);//null
// console.log(null && 0);//null
// console.log(0 && undefined);//0
// console.log(1 && undefined);//undefined
// console.log(null && undefined);//null
// console.log(2 && 1 && null && 0 && undefined);//null


// //7) Есть ли разница между выражениями? 
// //!!( a && b ) и (a && b)
// console.log(!!( 1 && 2 ) === (1 && 2));//false
// //(!!)динамическая типизация два знака !! превращает следующее выражение в булиновое в итоге булиновое выражение не будет ровняться значению которое вернется из соседнего выражения
// console.log(!! ( 1 && 2 ));//true
// console.log(1 && 2);//2
// //true неравно 2


// //8) Что выведет этот код: alert( null || 2 && 3 || 4 );
// alert( null || 2 && 3 || 4 );//3
// // //логическое И (&&) ЗАПИНАЕТСЯ НА ЛЖИ - ВЫШЕ ПРИОРИТЕТ ЧЕМ У ИЛИ
// console.log(2 && 3);//3 - 2 И 3 - тру и тру
// // //логическое ИЛИ (||) ЗАПИНАЕТСЯ НА ПРАВДЕ - НИЖЕ ПРИОРИТЕТ ЧЕМ У И
// console.log(null || 3);//3 - фолз или тру запинается на правде и возвращает правду
// console.log(3 || 4);//3 - тру или тру запинается на правде и возвращает первую правду


// //9) a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b 
// const a = [1, 2, 3]; //ящик с зелеными яблоками 
// const b = [1, 2, 3]; //двугой ящик с другими яблоками, но содержимое похоже
// console.log(a == b);//false


// //10) Что выведет этот код alert( +"Infinity" );
// alert( +"Infinity");//Infinity -это просто строчка, 
// //но унарный+ говорит что это тип данных число
// console.log(typeof(+"Infinity"));//number


// //11) Верно ли сравнение: "Ёжик" > "яблоко"?
// console.log("Ёжик" > "яблоко");//false
// //строки сравниваем - посимвольное сравнение
// console.log("яблоко" > "Ёжик");//true


// //12) Чему равно 
// //0 || "" || 2 || undefined || true || falsе
// // //логическое ИЛИ (||) ЗАПИНАЕТСЯ НА ПРАВДЕ
// console.log(0 || "" || 2 || undefined || true || false);//2
// //фолз ИЛИ фолз ИЛИ тру



// //Упражнение по написанию кода 15: Задания на поиск ошибок в коде (debug)
// //Задание:
// //У вас есть объект с данными о ресторане. Начинающий разработчик создал несколько функций, которые работают неправильно и он не может понять почему. Нужно исправить функции так, чтобы они давали всегда правильный результат.

// //1) Функция isOpen не хочет правильно работать. Что мы уже не пробовали подставлять в неё - результат все время неправильный. Необходимо найти причины и исправить.

// //2) Функция isAverageLunchPriceTrue должна брать цены двух любых блюд из меню, складывать их и сравнивать с средним чеком (averageLunchPrice).
// //Сейчас функция работает, но постоянно выдает неправильный результат. Ведь из представленного меню сумма двух любых цен всегда будет больше 20. Необходимо найти причину и исправить.

// //3) Функция transferWaitors создана для того, чтобы копировать шаблон данных и передавать их в другой ресторан. Конечно, в другом ресторане будут другие блюда, другие официанты и тп. Сейчас эта функция только в начале разработки и должна менять данные про официантов.
// //Но в нынешнем виде мы обнаружили, что после её запуска не только копия данных содержит новых официантов, но и основные данные! В restorantData сотрудник Alice исчезает и заменяется Mike! Необходимо найти причину и немедленно исправить, чтобы данные были разделены.

// const restorantData = {
//     menu: [
//         {
//             name: 'Salad Caesar',
//             price: '14$'
//         },
//         {
//             name: 'Pizza Diavola',
//             price: '9$'
//         },
//         {
//             name: 'Beefsteak',
//             price: '17$'
//         },
//         {
//             name: 'Napolean',
//             price: '7$'
//         }
//     ],
//     waitors: [
//         {
//             name: 'Alice',
//             age: 22
//         },
//         {
//             name: 'John',
//             age: 24
//         }
//     ],
//     averageLunchPrice: '20$',//средняя цена обеда
//     openNow: true//открыто сейчас
// };

// function isOpen(prop) {
//     let answer = '';
//     prop ? answer = 'Закрыто' : answer = 'Открыто';

//     return answer;
// }

// console.log(isOpen(restorantData.openNow));//не работало, добавила restorantData.//Закрыто



// //до исправления ошибок:
// // function isAverageLunchPriceTrue(fDish, sDish, average) {
// //     if (+fDish.price.slice(0, -1) + (sDish.price) < average) {
// //         return 'Цена ниже средней';
// //     } else {
// //         return 'Цена выше средней';
// //     }
// // }
// // console.log(isAverageLunchPriceTrue(restorantData.menu[0], restorantData.menu[1], restorantData.averageLunchPrice));//Цена ниже средней

// //после исправления ошибок
// function isAverageLunchPriceTrue(fDish, sDish, average) {
//     if (+fDish.price.slice(0, -1) + (+sDish.price.slice(0, -1)) < +average.slice(0, -1)) {
//         return 'Цена ниже средней';
//     } else {
//         return 'Цена выше средней';
//     }
// }
// console.log(isAverageLunchPriceTrue(restorantData.menu[0], restorantData.menu[1], restorantData.averageLunchPrice));//Цена выше средней
// //было (sDish.price) стало (+sDish.price.slice(0, -1))
// //было average стало +average.slice(0, -1))
// //код ДО работал, код ПОСЛЕ работает, изменился ответ



// function transferWaitors(data) {
//     const copy = Object.assign({}, data);
//     // copy.waitors[0] = {name: 'Mike', age: 32};//неправильно
//     copy.waitors = [{name: 'Mike', age: 32}];//правильно
//     return copy;
// }
// console.log(transferWaitors(restorantData));
// //ДО
// // {
// //     menu: [
// //       { name: 'Salad Caesar', price: '14$' },
// //       { name: 'Pizza Diavola', price: '9$' },
// //       { name: 'Beefsteak', price: '17$' },
// //       { name: 'Napolean', price: '7$' }
// //     ],
// //     waitors: [ { name: 'Mike', age: 32 }, { name: 'John', age: 24 } ],
// //     averageLunchPrice: '20$',
// //     openNow: true
// // }
// // ПОСЛЕ
// // {
// //     menu: [
// //       { name: 'Salad Caesar', price: '14$' },
// //       { name: 'Pizza Diavola', price: '9$' },
// //       { name: 'Beefsteak', price: '17$' },
// //       { name: 'Napolean', price: '7$' }
// //     ],
// //     waitors: [ { name: 'Mike', age: 32 } ],
// //     averageLunchPrice: '20$',
// //     openNow: true
// // }




// //урок 43 Действия с элементами на странице
// // const box = document.getElementById('box');
// // console.log(box);//отображает элемент с айди box


// // const btns = document.getElementsByTagName('button');
// // console.log(btns);//отображает массив из всех кнопок
// // если в хтмл оставить только одну кнопку, то все равно вернется массив но с одним значением

// // const btns = document.getElementsByTagName('button')[1];
// // console.log(btns);//отображает 2 элемент

// // const btns = document.getElementsByTagName('button');
// // console.log(btns[1]);//отображает 2 элемент


// // const circles = document.getElementsByClassName('circle');//class-без точки
// // console.log(circles);//возвращает массив всех circle


// // const hearts = document.querySelectorAll('.heart');
// // //console.log(hearts);//возвращает массив всех heart
// // hearts.forEach(item => {
// //     console.log(item);
// // });//возвращает одно сердечко
// //
// // const oneHeart = document.querySelector('.heart');
// // console.log(oneHeart);//возвращает одно сердечко

// // const oneHeart = document.querySelector('div');
// // console.log(oneHeart);//возвращает первый на странице див box

// const box = document.getElementById('box'),
//       btns = document.getElementsByTagName('button'),
//       circles = document.getElementsByClassName('circle'),
//       wrapper = document.querySelector('.wrapper'),
//       hearts = wrapper.querySelectorAll('.heart'),
//       oneHeart = wrapper.querySelector('.heart');

// //console.dir(box);//получаем элемент в качестве объекта


// // box.style.backgroundColor = 'blue'; //меняем элементу box цвет
// // box.style.width = '500px';//меняем элементу box ширину
// box.style.cssText = 'background-color: blue; width: 500px';


// btns[1].style.borderRadius = '100%';//кнопка2 (индекс1) становится овальная
// circles[0].style.backgroundColor = 'red';//окрасила первый кружок в красный цвет


// // for (let i = 0; i < hearts.length; i++) {
// //     hearts[i].style.backgroundColor = 'blue';
// // }//окрасило фон сердечек так как сами сердечки созданы через after-before
// //
// hearts.forEach(item => {
//     item.style.backgroundColor = 'blue';
// });//работает точно также


// const div = document.createElement('div');//существует только в js на странице не появится
// //const text = document.createTextNode('Тут был я');


// div.classList.add('black');//добавили див с классом блэк, но без document он не отобразиться на странице
// document.body.append(div);//в конец бади создали див с классом black получили черный прямоугольник стили он взял из css
// //document.querySelector('.wrapper').append(div);//в обертку wrapper добавился элемент див с классом блэк, но можно добавить его в переменные если он используется несколько раз const wrapper = document.querySelector('.wrapper');  тогда переписываем код:
// //wrapper.append(div);
// //wrapper.appendChild(div);//разницы нет
// //wrapper.prepend(div);//черный прямоугольник перескакивает выше сердечек в блоке wrapper ИЛИ:
// //hearts[0].before(div);//черный прямоугольник перед 1 сердечком
// //hearts[0].after(div);//черный прямоугольник встал после первого красного сердечка
// //wrapper.insertBefore(div, hearts[0]);//черный прямоугольник вставляю в начало wrapper
// //wrapper.insertBefore(div, hearts[1]);//черный прямоугольник вставляю после первого сердечка


// //circles[0].remove();//удалила первый кружочек
// //wrapper.removeChild(hearts[1]);//удалила второе сердечко

// hearts[0].replaceWith(circles[0]);//поменяла первое сердце на первый кружочек (кружочек перенесен на новое место)
// //wrapper.replaceChild(circles[0], hearts[0]);//вместо 1 сердечка встает 1 кружочек. (вначале элемент который переставляют, потом на чье место)


// //div.innerHTML = "Hello World";
// div.innerHTML = "<h1>Hello World</h1>";//можно вставить хтмлкод на черный прямоугольник
// //div.textContent = "Hello";//можно вставить текст на черный прямоугольник
// //div.textContent = "<h1>Hello World</h1>";//текст на черном прямоугольнике: <h1>Hello World</h1>
// //то для безопасности: иногда данные получаем от пользователя и если данные полученные от пользователя попадают в innerHTML это может повлиять на сайт и сломать верстку, поэтому пользователь может записывать информацию только в поле textContent



// //div.insertAdjacentHTML("afterbegin", '<h2>Hello</h2>');//h2 идет ДО h1 ВНУТРИ обертки див блэк
// //div.insertAdjacentHTML("beforeend", '<h2>Hello</h2>');//h2 идет ПОСЛЕ h1 ВНУТРИ обертки див блэк
// //div.insertAdjacentHTML("beforebegin", '<h2>Hello</h2>'); //h2 идет ДО h1 ВНЕ обертки див блэк
// //div.insertAdjacentHTML("afterend", '<h2>Hello</h2>');//h2 идет после h1 ВНЕ обертки див блэк

// //урок 45 События и их обработчики
// //событие - это сигнал от браузера, что что-то произошло(клик, двойной клик, наведение мыши, убрать мышь, прокрутка колесиком, отправка данных в форме, нажатие клавиш на клавиатуре) то что пользователь занимается на странице и есть событие и мы их можем отлавливать

// //const btn = document.querySelector('button');//ЗАКОММЕНТИЛА КОГДА РАЗБИРАЛА querySelectorAll


// // btn.onclick = function() {
// //     alert('Click');
// // };//УСТАРЕВШИЙ вариант-перезаписывается другим обработчиком
// // btn.onclick = function() {
// //     alert('Second click');
// // };//при том, что есть первый обработчик, второй обработчик перезаписывает и при нажатии на кнопку - вылезает только второй алерт


// //eventListener - слушатель события
// // btn.addEventListener('click', () => {
// //     alert('Click');
// // });
// // btn.addEventListener('click', () => {
// //     alert('Second click');
// // });//при клике появляется первый алерт, а за ним второй

// //btn.addEventListener('mouseenter', (event) => {
//     //alert('Hover');//при наведении на кнопку btn вылезает алерт на котором написано Hover
//     //console.log('Hover');//при каждом наведении мышки на кнопку btn в консоли пишется Hover  счетчик
//     //console.log(event);//возвращает объект который описывает что произошло с элементом на который навели мышку MouseEvent {isTrusted: true, screenX: 109, screenY: 137, clientX: 102, clientY: 9, …}
//     //важное свойство type: "mouseenter" - тип события который произошел
//     //важное свойство target: button#btn - элемент на котором произошло событие
//     //console.log(event.target);//консоль возвращает <button id="btn">Нажми меня</button>
//     //event.target.remove();//при наведении на кнопку она пропадает со страницы
//     //если вместо 'mouseenter' написать 'click' - элемент пропадает при клике
// //});


// //delete
// //let i = 0;
// //const deleteElement = (event) => {
// //    console.log(event.target);
// //    i++;
// //    if (i == 1) {
// //        btn.removeEventListener('click', deleteElement);
// //    }
// //};
// //btn.addEventListener('click', deleteElement);
// //один ответ и больше ничего не происходит


// //всплытие событий
// const overlay = document.querySelector('.overlay');
// const deleteElement = (event) => {
//     console.log(event.target);
//     //console.log(event.currentTarget);//другой способ таргета
//     console.log(event.type);

// };
// //btn.addEventListener('click', deleteElement);//ЗАКОММЕНТИЛА КОГДА РАЗБИРАЛА querySelectorAll
// //overlay.addEventListener('click', deleteElement);//ЗАКОММЕНТИЛА КОГДА РАЗБИРАЛА querySelectorAll
// //при нажатии на кнопку в консоль я получаю два результата
// //вначале событие сработало на том элементе которое идет вложеннее (кнопка)
// //и после этого по иерархии вверх оно поднялось и уже сработала на розовой области overlay - это и называется всплытие событий
// //когда данное действие срабатывает вначале на вложенном элементе и после этого поднимается наверх по иерархии нашего дом-дерева
// //всплытие событий это когда обработчик событий сначала срабатывает на самом вложенном элементе, затем на родителе, и так выше и выше поднимаясь по иерархии 


// //важно уметь отменять стандартное поведение в браузере 
// const link = document.querySelector('a');
// link.addEventListener('click', function(e) {
//     e.preventDefault();
//     console.log(e.target);
// });//отменяет стандартное поведение браузера при нажатии на ссылку раньше переход на ютуб, а теперь в консоли ответ <a href="https://www.youtube.com/">https://www.youtube.com/</a>


// // //querySelectorAll возвращает псевдомассив у которого нет метода addEventListener
// // //если я делаю:
// // const btns = document.querySelectorAll('button');
// // btns.forEach(item => {
// //     item.addEventListener('click', deleteElement, {once: true});
// // });//теперь каждая кнопка работает
// // //once - один раз аналог remove удаления после того как сработает
// //закомментировала когда тестировала адаптивность - консоль ругается что btns несколько раз объявлена


//урок 47 рекурсия

// function pow(x, n) {
//     let result = 1;
//     for (let i = 0; i < n; i++) {
//         result *= x;//это result = result * x
//     }
//     return result;
// }//цикл

// function pow(x, n) {
//     if (n === 1) {
//         return x;
//     } else {
//         return x * pow(x, n - 1);
//     }
// }//рекурсия


// console.log(pow(2, 1));//2-два в первой степени
// console.log(pow(2, 2));//4
// console.log(pow(2, 3));//8
// console.log(pow(2, 4));//16


// let students = {
//     js: [{
//         name: 'John',
//         progress: 100
//     }, {
//         name: 'Ivan',
//         progress: 60
//     }],

//     html: {
//         basic: [{
//             name: 'Peter',
//             progress: 20
//         }, {
//             name: 'Ann',
//             progress: 18
//         }],

//         pro: [{
//             name: 'Sam',
//             progress: 10
//         }],

//         semi: {
//             students: [{
//                 name: 'Test',
//                 progress: 100
//             }]
//         }
//     }
// };

//посчитать средний прогресс студентов со всех курсов
// //цикл:
// function getTotalProgressByIteration(data) {
//     let totalProgress = 0;
//     let students = 0;

//     for (let course of Object.values(data)) {
//         if (Array.isArray(course)) {
//             students = students + course.length;
//             //students += course.length;

//             for (let i = 0; i < course.length; i++) {
//                 totalProgress = totalProgress + course[i].progress;
//                 //total += course[i].progress;
//             }
//         } else {
//             for (let subCourse of Object.values(course)) {
//                 students = students + subCourse.length;
//                 //students += subCourse.length;

//                 for (let i = 0; i < subCourse.length; i++) {
//                     totalProgress = totalProgress + subCourse[i].progress;
//                     //total += subCourse[i].progress;
//                 }
//             }
//         }
//     }

//     return totalProgress / students;
// }
// console.log(getTotalProgressByIteration(students));//41.6
// //цикл вначале что делаем с массивами, потом что делаем с объектами
// //course это общий массив - правая сторона студентс (js & html опускаются) остается name-john и тд 
// //этот код для структуры когда идет перебор массивов внутри объекта, если в список добавится объект то есть [], [], [], {} то надо добавлять еще условие внутри условия и так до бесконечности (тут помогает рекурсия)
// //рекурсия заносит в функцию повторяющееся части кода 


// //рекурсия:
// //if если массив, else если объект
// function getTotalProgressByRecursion(data) {
//     if (Array.isArray(data)) {
//         let totalProgress = 0;

//         for (let i = 0; i < data.length; i++) {
//             totalProgress = totalProgress + data[i].progress;
//         }

//         return [totalProgress, data.length];
//     } else {
//         let totalProgress = [0, 0];

//         for (let subData of Object.values(data)) {
//             const subDataArr = getTotalProgressByRecursion(subData);
//             totalProgress[0] = totalProgress[0] + subDataArr[0]; 
//             totalProgress[1] = totalProgress[1] + subDataArr[1];
//         }

//         return totalProgress;
//     }
// }

// const result = getTotalProgressByRecursion(students);

// //console.log(result[0]/result[1]);//41.6 - let без semi

// //обавила в let students внутрь html - semi
// //список массив, массив, объект
// //{{[][]{}}}
// // semi: {
// //     students: [{
// //         name: 'Test',
// //         progress: 100
// //     }]
// // }
// //первая функция с циклом расчитана на определенную структуру: обработает массив, массив, а потом поломается об объект

// //снова запускаем функцию рекурсию с учетом нового let

// console.log(result[0]/result[1]);//51.333333333333336
// //теперь функция работает с любой вложенностью сколько бы мы не добавляли структур



// //упражнение по написанию кода 16:(*) Задача на рекурсию

// //Напишите функцию, которая вычисляет факториал.
// //Факториал  – это число, умноженное на "себя минус один", затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!
// //Отсюда мы можем понять, что функция должна принимать 1 аргумент, который будет являться числом. 
// //Будет неплохо, если вы на собеседовании сразу напишите проверку на приходящее значение = если в нашу функцию приходит дробное число или не число  - возвращается строка с любым сообщением на ваше усмотрение. Если 0 и меньше - возвращается число 1.
// //Сам же факториал с примерами выглядит вот так:
// //n! = n * (n - 1) * (n - 2) * ...*1 - это общая формула
// //Примеры значений для разных n:
// //1! = 1
// //2! = 2 * 1 = 2
// //3! = 3 * 2 * 1 = 6
// //4! = 4 * 3 * 2 * 1 = 24
// //5! = 5 * 4 * 3 * 2 * 1 = 120
// //То есть, вызов нашей функции factorial(5) возвращает число 120
// //factorial(4) => 24
// //Решить задачу нужно через рекурсию.
// //Integer - Целое число


// // function factorial(n) {
// //     return n ? n * factorial(n - 1) : 1;
// // }
// // console.log(factorial(5));//120-короткий вариант
// // console.log(factorial(-5));//ошибка-не учитывает отрицательные значения


// function factorial(n) {
//     if (typeof(n) !== 'number' || !Number.isInteger(n)) {
//         return "Ошибка, проверьте данные";
//     }

//     if (n >= 1) {
//         return n * factorial(n - 1);
//     } else {
//         return 1;
//     }
// }

// console.log(factorial(5));//120
// console.log(factorial(-5));//1



// //урок 49. События на мобильных устройствах
// //поддерживается только в мобильных браузерах
// //события:
// // 1) touchstart - событие выполняется при касании к элементу
// // 2) touchmove - при движении пальца по элементу
// // 3) touchend - когда палец отрывается от элемента
// // 4) touchenter - срабатывает когда пальцем ведем и наскакиваем на элемент на который повешено событие
// // 5) touchleave - срабатывает когда пальцем ведем и рошел за пределы элемента на который повешено событие
// // 6) touchcancel - точка соприкосновения больше не регистрируется на поверхности(палец вышел за пределы браузера)

// window.addEventListener('DOMContentLoaded', () => {
//     const boxTouch = document.querySelector('.boxTouch');

//     boxTouch.addEventListener('touchstart', (e) => {
//         e.preventDefault();//отменяет стандартное поведение браузера

//         console.log('Start');
//         //console.log(e.touches);//ответ TouchList {0: Touch, length: 1} - 1 палец
//         console.log(e.targetTouches);//почти тоже самое, через адаптивность нельзя смоделировать несколько пальцев
//         console.log(e.changedTouches);//почти тоже самое, через адаптивность нельзя смоделировать несколько пальцев, но на мобильном устройстве все будет работать правильно: покажет список из пальцев которые коснулись элемента.
//     });//при клике на область в консоли выводится старт и счетчик сколько раз клацнули

//     boxTouch.addEventListener('touchmove', (e) => {
//         e.preventDefault();//отменяет стандартное поведение браузера

//         //console.log('Move');//тестирую targetTouches
//         console.log(e.targetTouches[0].pageX);//при движении нажатого пальца в консоль выводится координата-координаты xy в дальшейшем можно задавать на какую часть слайдера по координатам пользователь должен нажать чтобы слайдер перелистнулся, но есть уже готовые библиотеки типа hammer.js 
//     });//при нажатии и движении пальца по элементу в консоли выводится move и счетчик сколько раз передвинули палец

//     boxTouch.addEventListener('touchend', (e) => {
//         e.preventDefault();//отменяет стандартное поведение браузера

//         console.log('End');
//     });//при убирании пальца от элемента в консоли выводится end и счетчик сколько раз убрали палец
// });

// //три главных свойства при работе с сенсорными устройствами
// //1) touches - св-во которое выдает нам список всех пальцев которые сейчас взаимодействуют с экраном (прямо сейчас тапнули и держат пользователи)
// //чтобы увидеть пишу console.log(e.touches);
// //ответ объект TouchList {0: Touch, length: 1} - 1 палец
// //length - то количество пальцев
// //target - с каким элементом произошло действие
// //координаты xy в дальшейшем можно задавать на какую часть слайдера по координатам пользователь должен нажать чтобы слайдер перелистнулся
// //2) targetTouches - св-во все пальцы которые взаимодействуют именно с этим элементом конкретным
// //3) changedTouches - список пальцев которые участвуют в текущем событии. То есть если приложить 5 пальцев и при использовании touchEnd в списке будет 1 убранный палец даже если остальные 4 еще на экране.
// //еще есть свайп, щепотка(зум)



// //урок 50 
// //как подключить script.js

// function loadScript(src) {
//     const script = document.createElement('script');
//     script.src = src;
//     script.async = false;
//     document.body.append(script);
// }

// // loadScript("js/script.js"); почему-то здесь не подключает js в котором куча всего, только новые в которых 1 запись:
// loadScript("js/some.js");
// loadScript("js/test.js");



// //упражнение по написанию кода 17*** сложная задача на вычисление количества страниц
// //Задание:
// //В каждой книге есть n страниц с номерами страниц от 1 до n. Написать функцию amountOfPages, аргумент которой summary составляется путем сложения количества цифр всех номеров страниц. Эта функция возвращает число - количество страниц n в книге. Чтобы было понятно что такое количество цифр, давайте рассмотрим примеры.
// //Пример:
// //Если на входе функции summary = 25, то на результат должен быть 17. Всего в числах от 1 до 17 содержится 25 цифр: 1234567891011121314151617.
// //Функция на вход как раз принимает это общее количество цифр, а возвращает конечное число, то есть последнюю страницу книги.
// //amountOfPages(5) => 5
// //amountOfPages(25) => 17
// //amountOfPages(1095) => 401   
// //amountOfPages(185) => 97

// function amountOfPages(summary) {
//     let result = '';
//     let n = 0;

//     for (let i = 1; i <= summary; i++) {
//         result += i;
//         if (result.length === summary) {
//             n = i;
//             break;
//         }
//     }
//     return n;
// }



// //Упражнение по написанию кода 18** Сложная задача на работу со строками
// //Задание:
// //Панграмма — это предложение, в котором каждая буква алфавита встречается хотя бы по одному разу по возможности без повторений. Например, предложение «The quick brown fox jumps over the lazy dog» является панграммой, поскольку в нем хотя бы один раз используются буквы от A до Z (регистр значения не имеет).
// //Напишите функцию isPangram, которая принимает в себя строку и возвращает логическое значение. Если строка является панграммой - вернется true, если нет - false.
// //Пример:
// //isPangram(«The quick brown fox jumps over the lazy dog») => true
// //isPangram(«Hello world») => false

// //1 вариант, когда строка переводится в нижний регистр до всех операций только 1 раз - это должно экономить ресурсы компьютера
// function isPangram(string) {
//     string = string.toLowerCase();
//     return "abcdefghijklmnopqrstuvwxyz".split("").every(function(x){
//         return string.indexOf(x) !== -1;
//     });
// }

// //2 вариант - с другим методом и строка каждый раз преобразовывается в коллбэке
// function isPangram(string) {
//     return 'abcdefghijklmnopqrstuvwxyz'
//         .split('')
//         .every((x) => string.toLowerCase().includes(x));
// }

// //3 вариант - при помощи цикла
// function isPangram(str) {
//     letters: for (var c = 0; c < 26; c++) {
//         for (let i = 0; i < str.length; i++) {
//             let s = str.charCodeAt(i)
//             if (s < 65 || s > 90 && s < 97 || s > 122) continue
//             if (s === 65 + c || s === 97 + c) continue letters
//         }

//         return false
//     }

//     return true
// }

// //4 вариант - при помощи set
// function isPangram(string) {
//     return new Set(string.toLocaleLowerCase().replace(/[^a-z]/gi, '').split('')).size === 26;
// }

// //5 вариант - с использованием регулярных выражений
// function isPangram(string) {
//     return (string.match(/([a-z])(?!.*\1)/ig) || []).length === 26;
// }



// //упражнение по написанию кода 19** сложная задача на работу с рекурсией
// //Задание:
// //Создайте функцию deepCount, которая будет считать количество всех элементов в массиве, включая и вложенные массивы. Учтите, что сам вложенный массив тоже входит в счет. Чтобы понять задачу детальнее, давайте рассмотрим примеры:
// //deepCount([1, 5, 3]) => 3
// //deepCount(["1", 5, "3", ["10"]]) => 5 (Заметьте, что последний элемент был посчитан сам + его внутренность)
// //deepCount([1, 2, [3, 4, [5]]]) => 7
// //deepCount([]) => 0
// //deepCount([[[[[[[[[]]]]]]]]]) => 8

// //1 вариант с циклом
// function deepCount(a) {
//     let count = a.length;
//     for (let i = 0; i < a.length; i++) if (Array.isArray(a[i])) count += deepCount(a[i]);
//     return count;
// }

// //2 вариант в методом reduce
// function deepCount(a) {
//     return a.reduce((s,e)=>s+(Array.isArray(e) ? deepCount(e) : 0),a.length);
// }
//
//
//
//Урок 76 контекст вызова this 

//контекст вызова виз - это то что окружает функцию и в каких условиях она вызывается
//человек без определенного места жительства - этот человек функционирует в пределах всего мира, у него нет конкретной привязки к месту
//если мы поместим этого человека в специальном учреждении где он может жить и чем-то заниматься - он получит контекст вызова, у него есть место для функционирования 
//функции в джаваскрипте ведут себя точно также
//контекст одна из самых сложных тем которые есть в джаваскрипте для понимания новичков
//функция может вызываться четырьмя способами
//и в каждом контекст вызова отличается
//1 метод это просто вызов нашей функции 
// function showThis() {
//     console.log(this);
// }
// showThis();
//виз будет вести себя по разному в зависимости от того установлен строгий режим или нет
//если закомментировать 'use strict';
//ушло подчеркивание this (желтая волна) подсказка js-хинт
//смотрим как работает: открываем браузер вкладку консоль разработчика
//на 4 строке получаем window это глобальный объект который мы уже разбирали
//вывод - если функция просто запускается таким образом showThis(); когда мы используем в ней контекст (this) то этот контекст будет ссылаться на глобальный объект виндоу - это правило верно для обычного кода без строгого режима (юзе стрикт), но когда мы включаем строгий режим юзе стрикт у нас сразу подсказка подчеркивается виз встает в позицию андефайнд 
//в консоли на строке 4 - undefined
// 1) Обычная функция: 
//НЕТ use strict: this = window, но если 
//ЕСТЬ use strict: this = undefined

//2 метод
//внутри функции напишем еще одну функцию сум которая будет передавать сумму двух аргументов return a + b но можно прописать это с использованием контекста this.a + this.b
//посмотреть что написано внутри функции сум - консольлог виз 
//и вконце эту функцию нужно вызвать с помощью консольлога чтоб увидеть в консоли
//вызываем шоуВиз и передаем аргументы 4 и 5
//какой контекст вызова у функции сум?
//будет ли работать ритерн и ексли нет как его исправить
// function showThis( a, b) {
//     console.log(this);
//     function sum() {
//         console.log(this);
//         return this.a + this.b;
//     }
//     console.log(sum());
// }
// showThis(4, 5);
//остановилась 4-28 продолжить писать конспект
//в консоли ответ:
//строка 4 - undefined
//строка 6 - undefined
//консольлог виз тут точно также будет равен андефайнд (из-за юзе стрикта)
//не важно где функция запускается, важно что у нее контекст вызова будет либо window либо undefined - зависит от режима
//даже если используется функция внутри функции контекст у нее не меняется именно поэтому мы два раза в консоль получаем андефайнд так как у нас два консольлога


//второй вопрос как сделать так чтобы наши переменные наша сумма вообще работала ответ простой нам достаточно здесь использовать замыкания функций то есть мы this из this.a просто убираем и оставляем a + b
//этих аргументов этих переменных в функции сум нет но за счет того, что у нас есть замыкание функций мы с вами когда запускаем сум она ищет вначале эти переменные внутри себя она их не находит и она обращается уже к родительской функции шоуВиз и имеет доступ к двум аргументам a, b которые мы передавали в showThis(4, 5) можем сохранить код:
// 'use strict';
// function showThis(a, b) {
//     console.log(this);
//     function sum() {
//         console.log(this);
//         return a + b;
//     }
//     console.log(sum());
// }
// showThis(4, 5);
//в консоли ответ 9
//остановилась 5-38 продолжить конспектировать

//способ вызова функции номер 2 методы объектов это тоже функции создаю const obj и его раскрываю свойство а со значением 20, какой-то метод который будет называться сум сюда мы помещаем функцию и чего мы хотим достичь? посмотреть какой контекст вызова будет у этой функции и чтобы это сделать не забываем вызвать этот метод обжект сум. чтобы не было лишних значений закомментирую предыдушие функции.
// 'use strict';
// const obj = {
//     a: 20,
//     b: 15,
//     sum: function() {
//         console.log(this);
//     }
// };
// obj.sum();
//в консоли ответ: { a: 20, b: 15, sum: [Function: sum] }
//интересное значение объект в котором свойство ключ-значение, свойство ключ-значение и функция
//получили постулат второго пункта
//если мы используем метод внутри объекта то контекст вызова всегда будет ссылаться на этот вот объект obj
//2) Контекст у методов объекта это будет сам объект

//предлагают поэкспериментировать если внутри этого метода будет создана какая-то функция например шауд которая внутри себя уже будет обращаться к контексту вызова и джеэсхинт что-то подсвечивает и этуже функцию мы вызываем внутри этого метода - мы сейчас смотрим контекст вызова именно функции шауд
// 'use strict';
// const obj = {
//     a: 20,
//     b: 15,
//     sum: function() {
//         function shout() {
//             console.log(this);
//         }
//         shout();
//     }
// };
// obj.sum();
//в консоли ответ undefined
//почему? это простой вызов функции он уже не относится к методу, это не метод объекта это функция которая запускается внутри метода поэтому контекст вызова (виз внутри шауд) здесь она просто взяла и потеряла - это как раз относится к нашему первому пункту который мы с вами уже разобрали 

//переходим к третьей ситуации когда еще вызываются функции - функции конструкторы через оператор new
//вставляю код из предыдущего урока и на нему буду экспериментировать
// 'use strict';
// function User(name, id) {
//     this.name = name;
//     this.id = id;
//     this.human = true;
//     this.hello = function() {
//         console.log("Hello! " + this.name);
//     };
// }
// let ivan = new User('Ivan', 23);
//это функция конструктор. когда функция будет вызвана она создаст новый объект в {} ы прописываем свойства которые обращаются в виз 
//виз дат нэйм
//дат dot это точка по английски
//для того чтобы записать какое-то свойство обращаемся к чему-то к какому-то объекту и это действительно будет объект внутри функции конструктора контекст вызова для всех методов и свойств будет только что созданный новый объект то есть в данном случае это например иван - виз всегда ссылается на вот эту вот new экземпляр который был создан в этой строчке и когда мы создаем этот новый объект мы записываем ему новое свойство - вместо виз мы подставляем вот этот новый объект (Ivan) и в это свойство name уже передаем то значение которое передали при создании этого объекта. дальше если у нас потом появятся какие-то методы внутри этого прототипа функции конструктора в виз.нэйм (который в функции хелллоу) ссылается на тот объект который мы только что с вами создали и причем берет его свойство нэйм которое мы уже записали в первой строке виз.нэйм=нэйм - это очень удобно ведь когда мы создаем все новые и новые экземпляры типа new User мы просто запоминаем то имя, тот айдишник который был у этого конкретного пользователя. тоже самое происходит в классах о которых мы будем говорить в следующем уроке

//3) this в конструкторах и классах - это новый экземпляр объекта - это правило выучить наизусть, на этом правиле будет строиться огромное количество интерактива в будущем. какую бы библиотеку или фреймворк вы в будущем не будете использовать (реакт, ангуляр, вью) - каждый раз будем сталкиваться с вот таким вот поведением this - если запомнить это правило в будущем никаких проблем не будет

//4) четвертый вариант - ручное присвоение this любой функции 
//создадим функцию сэйНэйм и во внутрь себя она будет помещать консольлог виз - для теста какой контекст вызова там и консольлог виз.нэйм какое имя я должна показать в консоль и помимо этого должен существовать какой-то юзер переменная это будет объект и у этого объекта будет свойство нэйм. и теперь главная задача как сделать так чтобы функция сэйНэйм когда запускалась она была как контекст не виндоу или андефайнд который сейчас появится, а именно юзера - то есть чтобы мы могли получить доступ к этому нэйму - отдаленно это напоминает метод this.hello = function() {} мы его запускали обращаясь к this и подвязывались под какой-то объект типа new User который здесь был создан, но здесь такого механизма нет, это отдельный механизм и есть два метода которые называются кол и эплай
//выглядит следующим образом:
//мы берем нашу функцию сэйНэйм ставим точку и у нее есть метод call  и во внутрь () мы передаем контекст вызова который мы хотим передать в эту функцию(user), тоже самое будет с эплай apply
//рассмотреть разницу между call и apply
//осталось конспектировать 15 минут видео. 12 минут конспектировала 2 часа 45 минут. увеличила помидор до 45 минут и стало легче
//остановилась 12-41
//разницы в синтаксисе никакой нет
//эти функции (call и apply) делают одно и тоже, разницы в функциональности нет, разница только в синтаксисе
// 'use strict';
// function sayName() {
//     console.log(this);
//     console.log(this.name);
// }
// const user = {
//     name: 'John'
// };
// sayName.call(user);
// sayName.apply(user);
//в консоли ответ:
//{ name: 'John' }//вначале контекст вызова console.log(this) контекстом вызова получаем тот объект к которому действительно привязались 
//John //тот метод который показывает нам имя у этого объекта 
//{ name: 'John' }
//John //причем два раза происходит одно и тоже с call и с apply
//что произошло: функция приобрела свой контекст благодаря тому что мы использовали два вот эти вот метода call и apply мы четко сказали эй функция заработай пожалуйста на вот этом объекте user и используй его данные - теперь мы можем гибко контролировать этот контекст вызова 
//действительно эти функции делают одно и тоже
//разница начинается тогда когда наша функция принимает дополнительные аргументы допустим нужно передать туда surname фамилию человека и этот аргумент передать при call-ставим запятую и аргументы передаются через запятую, а если используем apply -эти же аргументы передаем в массиве и через запятую:
// 'use strict';
// function sayName(surname) {
//     console.log(this);
//     console.log(this.name + surname);
// }
// const user = {
//     name: 'John'
// };
// sayName.call(user, 'Smith');
// sayName.apply(user, ['Smith']);
//в консоли ответ:
//{ name: 'John' }
//JohnSmith
//{ name: 'John' }
//JohnSmith
//это только два варианта ручного присвоения контекста, есть еще третий метод байнд - он уже создает новую функцию связанную с определенным контекстом. особое внимание на то что он создает новую функцию и под нее уже подвязывает контекст. у call, apply не создает новую функцию и под нее уже подвязывает контекст. здесь мы новую функцию не вызывали - контекст установили
//теперь напишем классический пример функции удваивания - функция каунт эта функция принимает какой-то нам и в итоге мы с вами возвращаем отсюда виз умноженное на нам - не хватает контекста вызова которое бы умножался на какое-то число которое было бы передано при вызове этой функции и здесь мы с вами можем использовать байнд. создаем новую переменную она будет называться дабл в эту переменную мы сейчас помещаем новую функцию - делается это так - мы обращаемся к существующей функции каунт дат байнд передадим контекст вызова двойку почему? функция называется дабл она должна удваивать любое число которое придет в эту функцию. то есть двойка переходит на место this, а num будет передаваться в функцию double. выглядит это следующим образом - берем консольлог и туда помещаем функцию дабл раскрываем скобки и сюда помещаем число которое хотим просто удвоить и еще поэкспериментировать с каким-нибудь числом 13. мы понимаем что дабл это новая функция у которой есть жестко привязанный контекст здесь это двоечка в байнд2 которая передается в this. и теперь в дабл мы можем передавать только один аргумент который будет всегда удваиваться. мы навсегда забили такую функцию
// function count(num) {
//     return this*num;
// }
// const double = count.bind(2);
// console.log(double(3));//6 потому что 2*3
// console.log(double(13));//26 потому что this это 2, num=13
//этот метод очень часто встречать в продвинутых вещах типа реакта
//4) четвертый метод ручная привязка this: call, apply, bind - это четвертый способ когда меняется контекст 

//обработчики событий
//есть простая кнопка в хтмл просто <button></button>
//увидим как она работает тоже с контекстом
//я создам переменную btn которая будет обращаться к документу и получать через квериселектор эту кнопку
//на эту кнопку навешиваем обработчик события на него будут кликать и я создаю обычную колбек функцию и мы хотим посмотреть чему будет равен контекст вызова виз если мы применим его прямо на нашем элементе
// 'use strict';
// const btn = document.querySelector('button');
// btn.addEventListener('click', function(){
//     console.log(this);
// });
//при нажатии на кнопку в консоль получаем <button></button> каждый раз когда нажимаем
//в таком случае контекстом вызова будет сам элемент на котором произошло событие, но так не всегда. есть стрелочные функции которые мы можем использовать в качестве колбекфункции разберем позже 
//когда обработчик события который идет как колбекфункция написан в классическом режими (фанкшн и круглые скобки) контекст вызова будет сам элемент на котором произошло событие. виз = ивентаргет. убедимся:
// 'use strict';
// const btn = document.querySelector('button');
// btn.addEventListener('click', function(){
//     this.style.backgroundColor = 'red';
// });
//при нажатии кнопка окрашивается в красный цвет, тоже самое мы можем сделать если будем использовать ивент-таргет
//в практике чаще используется объект события, а не контекст вызова



//ОСТАНОВИЛАСЬ на 20-06 осталось конспектировать 6 минут 
//разберем стрелочные функции и как они работают с контекстом вызова
//стрелочные функции вы можете использовать, но всегда должны помнить про особенность синтаксиса, а именно то что у стрелочной функции нет своего контекста вызова, она всегда его будет брать у своего родителя
//ПРИМЕР: если у бездомной женщины есть ребенок, то он всегда будет следовать за матерью и брать у нее этот контекст в котором они вместе где-то и находятся
//я еще раз создам какой-то объект назову его обж, здесь у меня будет какой-то нам = 5 и у нас будет функция которая называется сэйНамбер это будет именно метод - методы у объектов когда мы используем контекст внутри они ссылаютсчя на сами объекты, но если вдруг создать функцию внутри объекта контекст у нее поменяется. тут создадим стрелочную функцию которая будет называться Сэй и что она будет делать - в консоль выводить виз, ставим точку с запятой и вызовем Сэй и чтобы мы смогли увидеть нормальный результат работы мы обращаемся к обж и вызываем метод СэйНамбер. если бы у нас была обычная функция виз превратился бы в андефайнд, а мы используем стрелочную функцию - у нее нет своего контекста вызова, она всегда берет контекст у своего родителя - метод сэйНамбер, у метода (тут сэйНамбер) всегда контекст ссылается на объект в котором он существует(тут обж), соответственно у Виз по этому правилу будет ссылаться на сам объект obj 
// 'use strict';
// const obj = {
//     num: 5,
//     sayNumber: function() {
//         const say = () => {
//             console.log(this);
//         };
//         say();
//     }
// };
// obj.sayNumber();
//{ num: 5, sayNumber: [Function: sayNumber] }
//получаем объект, то есть виз превратился в ту часть что над ним нум и функция сэйНамбер
//сейчас это не понятно. но я конспектирую этот материал потому что это действительно важно. в будущем когда я буду с таким сталкиваться нужно будет вспоминать будет ли работать вот такой код когда виз в стрелочной функции. могу ли я в стрелочной функции сэй написать console.log(this.num) или мне нужно переделать эту функцию в обычную функцию(тогда будет андефайнд) или использовать здесь стрелочную и как это вообще работает - эти правила универсальные. 
// 'use strict';
// const obj = {
//     num: 5,
//     sayNumber: function() {
//         const say = () => {
//             console.log(this.num);
//         };
//         say();
//     }
// };
// obj.sayNumber();
//ответ 5
//потому что функция сэй обратилась к контексту вызова к объекту и взяла свойство нам и таким образом мы получили 5, если переделать в обычную функцию - получим ошибку
//стрелочные функции очень часто используются для модификации каких-то элементов прямо здесь на месте и у нее есть свои такие небольшие синтаксические нюансы 
//еще один примерчик напишем. у меня будет функция которая называется дабл нам нужна функция которая бы умножала какое-то число на два, сюда мы будем помещать стрелочную функцию, эта функция будет принимать какой-то аргумент эй мы задаем ее как стрелочную функцию. и в классическом варианте мы могли бы написать вот так: ретерн эй умноженное на 2, эта функция дабл будет возвращать непосредственно число которое задано в эй умноженное на 2 - это правильный синтаксис, оно так будет работать:
//'use strict';
// const double = (a) => {
//     return a * 2;
// };
// console.log(double(3));
//но стрелочная функция была создана для того чтобы укорачивать наш код и мы можем действительно сократить. и если тело функции помещается в одну строку, то мы можем написать его без фигурных скобок, но при этом красным цветом подчеркивается ретерн - поэтому мы убираем ключевое слово ретерн и наша стрелочная функция будет работать точно также, оно подставляется автоматически если действие помещается в одну строку надо записывать так, но ключевое слово писать не нужно оно подставится автоматически
//const double = (a) => return a * 2;//подчеркивает
//const double = (a) => a * 2;
//console.log(double(3));//6
//ОСТАНОВИЛАСЬ 24-00 продолжить писать конспект
// помимо этого мы еще больше можем сократить наш код. стрелочная функция если она принимает только один аргумент может быть написана без круглых скобок вот таким вот образом:
//const double = a => a * 2;
//console.log(double(3));//6
//получаю 6 это значит функция даже в таком синтаксисе правильно отработала, если функция кальк принимает два аргумента, то два аргумента нам уже придется оборачивать в круглые скобки иначе будет ошибка
//const calc = (a, b) => a * b * 2;
//console.log(calc(2, 2));//2*2*2=8
//а теперь возвращаемся к последнему пункту. контекст вызовов в обработчиках событий если мы используем стрелочую функцию
//const btn = document.querySelector('button');
//btn.addEventListener('click', function(){
//    this.style.backgroundColor = 'red';
//});
//мы уже видели что здесь виз обращается к самому элементу но если я вместо function напишу стрелочную функцию => 
//btn.addEventListener('click', () => {
//    this.style.backgroundColor = 'red';
//});
//при нажатии на кнопку наш код вернет ошибку в консоль backgroundColor - undefined это значит что контекст вызова здесь потерялся потому что у стрелочной функции своего контекста вызова здесь нет и соответственно она обращается к андефайнд, если не будет строгого режима use strict то будет обращаться к window поэтому здесь надо запомнить еще одно главное правило
//в обработчиках событий когда мы используем обычный синтаксис через function() мы имеем доступ к this это как раз тот элемент на котором происходит событие тоже самое что ивентТаргет 
//если же мы используем здесь стрелочную функцию () => то контекст вызова теряется мы его уже использовать не можем и this удет равен undefined 
//в большинстве случаев в практике мы используем ивентТаргет или какие-то похожие структуры то чаще всего вы в коде будете видеть стрелочные функции когда мы здесь задаем обработчик события и чтобы выполнить точно такое же событие мы сюда в () передаем эвент е и вместо this прописываем e.target 
//const btn = document.querySelector('button');
//btn.addEventListener('click', (e) => {
//    e.target.style.backgroundColor = 'red';
//});
//теперь при нажатии на кнопку происходит событие - кнопка окрашивается в красный цвет 
//какие-то нюансы со строгим режимом (use strict) были только в этом уроке
//в этом уроке мы разобрали все возможные варианты о контексте вызова, чему он может быть равен, в каких ситуациях как правильно поступать
//
//
//урок 77 классы (ес6)
//классы это красивая обертка функции конструтора или синтаксический сахар
//классы внутри это все те же функции
//похоже на функции-конструкторы
//начинается создание класса с ключевого слова class
//название класса всегда начинается с большой буквы (особенно это касается библиотек и фреймворков которые мы будем в будущем использовать)
//после имени класса мы раскрываем фигурные скобки
//теперь класс необходимо сконструировать то есть какие вещи у нас будут включаться в этот шаблон: что будет уметь этот класс, какие вещи и свойства в нем будут уже заданы изначально, важный параметр те аргументы которые будут подаваться извне (аргументы кастомизируют элемент) 
//свойство конструктор - чтобы сконструировать наш класс, расскрываем через круглые скобки-как в обычную функцию в круглых скобках записываем те аргументы которые будут приходить(у нашего прямоугольника будет высота какая-то и ширина какая-то-два эти параметра будут приходить извне при создании экземпляра класса)
//constructor(height, width) {
//  this.height = height;
//  this.width = width;
//}
//с помощью этого класса мы сможем сделать множество различных прямоугольников. например один 15*10 и он будет красного цвета, другой будет 5*4 и так далее
//когда мы передали сюда эти аргументы мы должны их записать в свойства этого нового объекта (классы и функции-конструторы служат нам для создания новых объектов) 
//дальше фигурные скобки. {если здесь мы будем обращаться к Виз мы будем обращаться к экземпляру нового созданного объекта, к каждому отдельному прямоугольнику, и мы говорим что в каждый такой новый объект записываем какое-то новое свойство например высота height и берем его из аргументов и записывается в свойство. тоже самое мы сделаем и с шириной width Виз точка ширина = ширина точка с запятой закрываем фигурную скобку }
//теперь у нас есть два базовых свойства которые будут записываться во время того как мы создаем наш класс и теперь создадим метод. методов у класса всегда будет много и их тоже надо уметь прописывать
//самый банальный метод - посчитать площадь прямоугольника  
//calcArea() {
//  return this.height * this.width;    
//}
//между конструктором и методом не нужно точку с запятой или между методом и методом - это будет ошибка
//методы просто записываются как какая-то функция calcArea() {} без названия фанкшн, без двоеточия
//внутри физурных скобок мы записываем что мы будем делать 
//{например наш метод должен возвращать прощадь прямоугольника мы прописываем ретюрн чтобы вернуть эту площадь и обращаемся в Виз (контекст вызова ссылается на новый объект который будет там создан) и мы берем из него свойство height высота и умножаем на Виз точка ширина width ставим точку с запятой - все метод готов}
//и класс тоже готов - теперь мы его можем использовать
//создаю переменную square это квадратик 
//ставлю знак присваивания =
//я сюда помещаю объект который создается при помощи класса для этого прописываю new название класса Rectange с большой буквы и внутрь () круглых скобок помещаем два аргумента 10 и 10
//const square = new Rectangle(10, 10);
//теперь в переменной square лежит объект у которого есть свойства this.height и this.width и у него есть метод calcArea - мы его как раз и можем использовать, так как метод возвращает что-то, а не выводит в консоль, сразу же используем кансольлог, обращаемся к этому объекту square и используем метод calcArea() так как это метод обязательно ставим круглые скобки чтобы у нас вызвался он
//можем протестировать этот код:
// class Rectangle {
//     constructor(height, width) {
//         this.height = height;
//         this.width = width;
//     }
//     calcArea() {
//         return this.height * this.width;
//     }
// }
// const square = new Rectangle(10, 10);
// const long = new Rectangle(20, 100);
// console.log(square.calcArea());//100 то 10*10
// console.log(long.calcArea());//2000 это 20*100
//при помощи классов создают две очень разные конструкции, которые содержат разные свойства(в конструкторе их сконструировали), но при этом содержат один и тотже метод калькЭриа 
//классы удобнее чем функции-конструкторы
//принципы объектно-ориентированного программирования
//1) абстракция - когда отделяем концепцию от ее экземпляра
//концепция это класс {конструктор(){это-это,это-вот это} метод(){что сделать}} это небольшой шаблон
//экземпляр - переменные конст квадрат = нью название класса в скобках аргументы 10 и 10
//2) наследование - способность нашего объекта или класса базироваться на другом объекте или классе (главный механизм для повторного использования кода) наследование классов будет четко определять их иерархию, пример: у нас есть большой класс тайтл это статьи которые могут быть на сайте, потом сайт разрастается и нужны будут статьи под разными рубриками (статьи по готовке и статьи по машиностроению) каждая из этих статей будет немножко кастомизирована, но будет прототип на основе которого будет что-то создаваться - идет иерархия вначале главный класс тайтл в котором будет содержаться много всего что будет содержаться в абсолютно всех статьях, потом идет распределение на различные тематики которые уже имеют свои собственные особенности, а потом от этих тематик отпочковываются отдельные экземпляры как мы делали конст скуэре = нью ректангл 10 10 и конст лонд = нью ректенгл 20 100
//после нашего базового класа ректенгл (в нем конструктор и калькЭриа) создадим еще один класс для цветных прямоугольников с текстом ColoredRectangleWithText - тут я понимаю, что у этого класса будут такие же свойства как у просто ректенгл (конструктор там будет и ширина и высота) и мне не надо дублировать этот код и метод прописывать если я могу сделать наследование - как сделать так чтобы он брал свойства и методы у ректенгл? для этого есть ключевое слово extends экстендс то есть наследуется от Rectangle название класса у которого наследуются и раскрываем фигурные скобки и в них точно также вызываем конструктор и для этого класса мы точно знаем какие аргументы мы будем передавать height width нам также понадобится текст text и какой-нибудь бэкграуд-колор bgColor, но вместо прописывания Виз точка хейт = хейт, виз точка хейт = хейт вместо контралзэ контравэ я пишу метод super() которая вызывает супер конструктор родителя - вызывает тоже самое что было у родителя - правило супер всегда должно быть на первом месте в конструкторе и в скобках указываю свойства которые нужно нужно наследовать (хейт и витх) не всегда все нужны свойства
//после прописываем виз точка текст = текст, виз точка бэкграундкалор = бэкграундкалор - все, наш класс уже сконструирован и мы можем его использовать. 
//помимо этого в нашем классе будет метод калькЭрия он тоже наследуется
//я создам еще один метод шоуМайПропс (чтобы было видно в кансоли как работает текст и бэкграунд калор) в фигурных скобках пропишу кансольлог открою бэктики и создам такую конструктию `Текст: ${this.text}, цвет: ${this.bgColor}`
//создаю конст див переменные во внутрь помещаю конструктор (с цветами и текстом) и туда помещаю аргументы 25 10 определенные текст и определенный цвет
//и я вначале протестирую тот метод который существует непосредственно в этом объекте в этом классе шоуМайПропс 
//а после я возьму кансольлог, обращусь к див, и буду использовать тот метод который существует в его родителе ректенгл
//и протестируем:
// class Rectangle {
//     constructor(height, width) {
//         this.height = height;
//         this.width = width;
//     }
//     calcArea() {
//         return this.height * this.width;
//     }
// }
// class ColoredRectangleWithText extends Rectangle {
//     constructor(height, width, text, bgColor) {
//         super(height, width);
//         this.text = text;
//         this.bgColor = bgColor;
//     }
//     showMyProps() {
//         console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
//     }
// }
// const div = new ColoredRectangleWithText(25, 10, 'Hello World', 'red');
// div.showMyProps();//Текст: Hello World, цвет: red
// console.log(div.calcArea());//250=25*10
//
//
////урок 80 rest-оператор и параметр по умолчанию спрет-оператор(оператор разворота) уже знакомились, рест его брат  который использует точно такой же синтаксис, но уже в других условиях спрет брал сущность и раскладывал ее на отдельные элементы, то рест у нас занимается обратным - рест отдельные элементы объединяет в один массив, если углубиться в название оператора, то рест можно перевести как "оставшиеся элементы" 
//посмотрим как это работает на практике: я создам переменную которая называется лог  это будет функция и эта функция (она принимает обязательно элементы: эй, би, и дальше мы не знаем сколько аргументов у нас может быть может ни одного а может быть десять, допустим мы ходим добавить определенные классы для наших элементов на странице мы четко знаем что там будет класс айтем класс меню, а остальные классы у нас будут опциональные они могут быть а может не существовать, но самое главное что они тоже приходят в качестве аргументов функции, пример: у нас может существовать программа которая расчитывает семейный бюджет и есть параметр который честко строго приходит это эй это зарплата мужа, би это зарплата жены, а все остальное может быть или не быть подработки-премии-подарки-итд дополнительные деньги которые могут прийти а могут не прийти и мы не знаем четко сколько этого всего будет и здесь нам нужен механизм который будет это контролировать и рест оператор этим занимается - рест-оператор прописывается как три точечки ... записывается всегда последним то есть вначале мы пишем аргументы которые будут обязательно а потом пишем рест-оператор который говорит что дальше будет бесконечное количество аргументов и назвать его можно как угодно можно рест можно си.) а далее в фигурных скобках {эта функция будет что-то выводить в консоль и там в скобочках прописываются аргументы так же (эй, би, рест) уже без точечек }, рест-опреатор собирает все оставшееся и формирует из этого массив, давайте в этом убедимся. дальше я буду вызывать функцию лог во внутрь () закинем такие строки как basic, rest - это первые обязательные эй и би, а дальше что угодно: "operator", "usage"
// const log = function(a, b, ...rest) {
//     console.log(a, b, rest);
// }
// log('basic', 'rest', 'operator', 'usage');
// //ответ в консоли: basic rest [ 'operator', 'usage' ]
//в консоли: две строчки нормально отображаются, мы их вывели в консоль, а две остальные у нас поместились в массив - это так сработал рест-оператор, он собрал отдельные сущности в массив, спред-оператор имеет обратную функцию, но точно такой же синтаксис он какой-то массив может разложить на отдельные элементы
//разберем параметр по умолчанию. иногда мы хотим чтобы в наших функциях параметры которые мы передаем по умолчанию имели какие-то значения. напишем еще одну функцию которая называется калькОрДабл которая будет либо вычислять значение или просто его умножать. в аргументы в круглых скобках напишу ( намбер-какое-то число и бэзис) открываю фигурные скобки {в консоли прописываем  значение намбер умноженное на бэзис и поставим точку с запятой}. если сейчас я вызову эту функцию калькОрДабл() и передам в скобках значение 3 и 5, то я конечно получу результат
// function calcOrDouble(number, basis) {
//     console.log(number * basis);
// }
// calcOrDouble(3, 5);
// //в консоли: 15
//но что будет если я не укажу второй аргумент?выйдет ошибка. надо чтобы был параметр по умолчанию. до стандарта ес6 использовали прием с использованием логического оператора или
// function calcOrDouble(number, basis) {
//     basis = basis || 2;
//     console.log(number * basis);
// }
// calcOrDouble(3);//6
//оператор ИЛИ вернет нам первую правду, если вдруг бэзис не был передан значит в нем андефайнд который по логическому контексту превращается в фолз ИЛИ 2 а двойка это всегда тру и соответственно из этого выражения нам вернется двойка потому что это первая правда и двойка запишется вместо бэзиса в итоге 3*2=6 но такая проверка иногда приводит к ошибке и это не надежный вариант и в стандарте ес6 стало все проще. теперь параметр по умолчанию можно записывать прямо при объявлении функции параметру бэзис присваивается значение 2 вместо андефайнд
// function calcOrDouble(number, basis = 2) {
//     console.log(number * basis);
// }
// calcOrDouble(3);//6
//можно задавать параметры элементов по умолчанию например высота и ширина модального окна, цвет текста, заднего фона и тому подобное. теорию разобрали, теперь можем применить на практике на нашем проекте фуд в js render() вся структура карточки menu__item оборачивается в один конкретный див в классе MenuCard в конструторе я в самом конце добавляю ...classes в перечень структуры и записываю наше свойство в {} чтоб его дальше можно было использовать, не забывать, что это массив и с ним нужно будет работать как с массивом, а не как с какими-то строками которые бы будем туда передавать в рендере вначале назначим классы так как это массив эта переменная Виз клэсес то нам нужно обработать этот массив, пройтись по каждому элементу внутри, вытащить название этого класса, и его подсоединить к этому диву обращаемся к виз точка клэсис точка форич я назову каждый элемент внутри этого массива как класснэйм стрелочная функция принимает этот аргумент и обращаюсь к элементу его класс-листу  и добавляю адд каждый класс который будет находится в этом массиве класНэйм ставим точку с запятой ну по факту это все что нужно было сделать с классами дальше убираем обертку <div class="menu__item"> дальше переходим в объявление наших классов new MenuCard последним аргументом после '.menu .container' но перед ).render пишем , 'menu__item' причем без точки потому что мы его потом поместим в массив и используем уже в класс-листе. если пользователь создавая new MenuCard забудет прописать дефолтный класс - весь сайт поломается, создалась карточка без класса и ничего не работает. вариант использования параметров по умолчанию можно подняться на самый верх там где задавали класс менюКард в конструкторе классы задавали через рест-оператор ...classes можно попробывать написать равно '.menu__item" сразу же видим ошибку что рест-параметр не поддерживает дефолтные значения, не подошло, убираем
//далее мы понимаем, что с помощью реста мы сформировали массив - мы же можем его дальше проходить при создании свойства (с помощью Виз клэсис) тут мы можем использовать наш старый способ при помощи оператора ИЛИ то есть пишем: this.classes = classes || 'menu__item'; наверное заработает? ведь если у нас в клэсис ничего не назначено - мы там назначим строку, но на самом деле здесь тоже будет проблема. проблема в 165 строке this.classes.forEach(className => element.classList.add(className)); если даже если вместо клэсис мы поместим строку - мы не сможем с ней работать, мы попытаемся строку перебрать через ворИч а этого метода просто не существует у строки и здесь тоже будет выдавать ошибку поэтому такой вариант нам тоже не подходит. что делать? когда мы не можем назначить рест-оператор, когда мы не можем использовать конструкцию с логическим оператором ИЛИ мы вспоминаем, что у нас есть самые обычные условия которые мы можем внутри метода рендер прописать ЕСЛИ вдруг в наш клэсис ничего не передается ни один элемент не передали  - мы просто присвоим этому элементу класс который нам там нужен menu__item есть одна особенность - мы в любом случае должны получить здесь массив  даже если он будет пустой (это еще одна из причин почему предыдущий метод не сработает - потому что у нас будет помещаться пустой массив, пустой массив не превращается в логический фолз)
//что я имею в виду? в методе рендер я введу console.log(this.classes) и из new MenuCard уберу класс menu__item в итоге в консоли - элементс класса нет, сайт развалился в консоли - консоль ошибка. во первых там отобразились карточки которые сформировались. первая пустой массив, 2 и 3 массив внутри которого "menu__item" заметить что в МенюКард не передан класс, но рест-оператор classes все равно вернул пустой массив - чтобы проверить передано сюда что-то или нет мы должны проверять не просто ...classes (тру) а именно количество элементов которые находятся в этом массиве ведь даже если в нем ничего не было он все равно сформирует пустой массив точно также ведут себя методы квериСелекторОЛ, гетЭлементсБай, клэсНейм и так далее когда мы пытаемся получить элементы со страницы по определенному селектору и он их там не находит он все равно будет формировать пустой массив в рендере кансольлог убираем и прописываем условие если Виз дат клэсис (это мой массив) мы обращаемся к его количеству элементов length будет строго равно === 0 то есть ни один элемент класса не был передан в таком случае я буду ставить дефолтный класс {element.classList.add()} делается это просто, элемент дат клэслист дат адд и мы сюда должны передать класс, но сделать это более грамотно вдруг нам этот класс в будущем понадобится запишу в свойства (сейчас тут пустой массив) я его перезаписываю и пишу что сейчас у меня там будет меню__айтем {this.element = 'menu__item'; element.classList.add();} я ставлю дефолтный класс который будет записываться в это свойство и я могу его вот так просто подставить в element.classList.add(this.element); если не были переданы ни одни классы то я сформирую их самостоятельно, если у меня есть хоть один класс, то я буду запускать вот эту вот часть: } else {this.classes.forEach(className => element.classList.add(className));} мы реализовали вручную без использования каких-то дефолтных значений, без использования хаков с логическими утверждениями просто использовали условие if-else  которое будет правильно отрабатывать я запускаю код и вижу что ошибок в консоли нет, карточки правильно сформировались, в верстке присутствует класс menu__item хотя при создании карточки в new MenuCard я ничего не передавала. То есть можно использовать условия, циклы и тд
//
//
//
// function setOptions(height, width, ...additional) {
//     console.log(height, width, ...additional)
// }
// setOptions(400, 500, 'red', 'top');//400 500 red top
// 
// 'use strict';
// function getSum(a, b) {
//     function sum() {
//         console.log(this.a);
//         return a + b;
//     }
//     console.log(sum());
// }
// getSum(4, 5);//ничего, будет ошибка в виз дат а
// 
//Делегирование событий - это прием, который позволяет...
//уменьшить количество обработчиков событий, 
//проще взаимодействовать с DOM-деревом, легко работать с неограниченным количеством элементов в родителе
// 
// class Slider {
//     constructor(width, height) {
//         this.width = width;
//         this.height = height;
//     }
//     showSliderWidth() {
//         console.log(this.width);
//     }
// }
// const slider = new Slider('500px', '150px');
// slider.showSliderWidth();//500px
// 
// // Какого метода не существует у свойства classList?
// //Атрибут class – уникален: ему соответствует аж целых два свойства!
// //Работать с классами как со строкой неудобно. Поэтому, кроме className, в современных браузерах есть свойство classList.
// //Свойство classList – это объект для работы с классами.
// //Методы classList:
// elem.classList.contains("class") // возвращает true/false, в зависимости от того, есть ли у элемента класс class.
// elem.classList.add/remove("class") // добавляет/удаляет класс class
// elem.classList.toggle("class") // если класса class нет, добавляет его, если есть – удаляет.
// // Кроме того, можно перебрать классы через for, так как classList – это псевдо-массив.
// //Например:
//     // var classList = document.body.classList;
//     // classList.remove('page'); // удалить класс
//     // classList.add('post'); // добавить класс
//     // for (var i = 0; i < classList.length; i++) { // перечислить классы
//     //   alert( classList[i] ); // main, затем post
//     // }
//     // alert( classList.contains('post') ); // проверить наличие класса
//     // alert( document.body.className ); // main post, тоже работает
// // в итоге ответ: есть методы contains, add, remove, toggle, нет метода includes
//
//какое свойство отвечает за ширину элемента, включая только сам контент и паддинг? clientWodth это обсуждалось в лекции Параметры документа, окна и работа с ними
//
//как правильно задать наследование одного класса от другого
//class Slider extends Element {}
//
//В чем ключевая разница между методами call и apply
//кол принимает аргументы через запятую (в виде строки)
//аплай принимает аргументы в виде массива
//
// const urlObj = {
//     protocol: 'https',
//     domain: 'mysite.com',
//     showCurrentURL: function() {
//         const extractCurrDomain = () => {
//             return this.domain;
//         }
//         const extractCurrProtocol = () => {
//             return this.protocol;
//         }
//         console.log(`${extractCurrProtocol()}://${extractCurrDomain()}`)
//     }
// }
// urlObj.showCurrentURL();//https://mysite.com
//
// const urlObj = {
//     protocol: 'https',
//     domain: 'mysite.com'
// }
// function showCurrentURL() {
//     const extractCurrDomain = () => {
//         return this.domain;
//     }
//     const extractCurrProtocol = () => {
//         return this.protocol;
//     }
//     console.log(`${extractCurrProtocol()}://${extractCurrDomain()}`)
// }
// const url = showCurrentURL.bind(urlObj);
// console.log(url);//[Function: bound showCurrentURL] или вывод самой функции
// //bind возвращает новую функцию
//
//свойство объекта события event.code позволяет получить
//код физической клавиши, которая была нажата. вне зависимости от зажатых клавиш shift или alt (урок создаем модальное окно)
//
//для чего необходимо сохранять уникальный идентификатор таймера
//const timerId = setInterval(func, 2000);
//для того, чтобы иметь возможность остановить этот конкретный таймер
//(это обсуждалось в уроке про setTimeout и setInterval)