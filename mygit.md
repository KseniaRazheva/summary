```
git status
git add .
git status
git commit -m "add/update/return files sass l.61" 
git push -u origin main
```

npm run gulp-запустить гульп
git checkout . - вернуть локальный репозиторий к состоянию последнего коммита который лежит на удаленном репозитории

//как поменять язык в вскоде открыть палитру команд ctrl+shift+p ввесли Configure Display Language нажать ентер и выбрать русский язык перезапустить приложение
//как сделать курсор в нескольких местах alt+левый клик по местам
//как поменять строки местами alt+стрелка вверх/стрелка вниз
//как закомментировать ctrl+/


коммит это снимок проекта

>git commit сделать коммит

делай ветки сразу, делай ветки часто

ветки хранит изменения текущего коммита и всех его родителей 

>git branch newImage создать новую ветку с именем newImage

C0 родитель ветки main
C1 коммит 2 создание новой ветки newImage но остаюсь еще на main

если после сделать бранч коммит С2 все равно будет в ветке main так как я не переключилась на новую ветку

после branch надо делать checkout

>git checkout newImage (git checkout имяветки) перейти на ранее созданную ветку, а потом git commit тогда С2 будет на новой ветке newImage 

создать ветку bugFix
git branch bugFix
переключиться на ветку bugFix
git checkout bugFix

создать новую ветку и переключиться на нее можно одной командой:
git checkout -b bugFix

слияние веток в гит: git merge (мержить)
при слиянии у коммита два родителя >git merge bugFix

смержим ветку main в ветку bugFix:
>git checkout bugFix,
>git merge main

задание:
- создай новую ветку под названием bugFix
>git branch bugFix
-переключись на новую ветку bugFix командой git checkout bugFix
>git checkout bugFix
-сделай один коммит
>git commit
-вернись на ветку main при помощи git checkout
>git checkout main
-сделай еще один коммит
>git commit
-слей ветку bugFix с веткой main при помощи git merge
>git merge bugFix !!! неправильно git merge main
-шпаргалка objective

git rebase- способ объединения изменений в ветках 
гит копирует набор коммитов и переносит в другое место
с помощью ребейс можно делать чистые и красивые линейные последовательности коммитов (история коммитов будет чище)

>git rebase main (сдвинуть изменения из bugFix в вершину ветки main чтобы все выглядело так будто изменения в main с0 с1 с2 и в bugFix с3 делались параллельно) таким образом c3 из отдельной ветки перемещается в ветку main 

>git rebase bugFix (сделаем rebase на bugFix)
main - родитель bugFix поэтому гит сдвинул ссылку на main вперед (те если от мэйн только одно ответвление с одним коммитом то он этот один коммит переносит на ветку мэйн)

задача:
>git branch bugFix
-создать ветку bugFix
-переключись на ветку bugFix
>git checkout bugFix
-сделай коммит
>git commit
-вернись на main и сделай коммит еще раз
>git checkout main
>git commit
-переключись на bugFix и сделай rebase на main
>git checkout bugFix
>git rebase main

------------------------------------------от сережи платонова
У тебя есть граф 
A -> Б  -> В -> Г
         \
          Д

Ребейс Д на Г сделает так, что Д будет идти за Г:
A -> Б  -> В -> Г -> Д


Только на самом деле это будет новый коммит Д*, оригинальный Д никуда не уходит. Но для пользователя он ничем не отличается, это тот же набор изменений

Гит перебазирует текущую ветку

Допустим ты сейчас на Д в примере выше, а main указывает на Г. Ты говоришь git rebase main, гит найдет какие коммиты в текущей ветке отличаются от ветки main (в данном случае только Д), он будет искать общий узел. То есть такой коммит, который входит в ветку main и текущую. В нашем примере Б уже входит в main и в текущую. После того как он нашёл нужные коммиты (в нашем случае только Д) он скопирует их, сохраняя порядок. Он как бы отрезает ветку от общего коммита (в примере это Б) и пришивает к тому, куда указывает main (у нас это Г)

------------------------------------------от сережи платонова 

_________________________от мужа_____________________________
чтобы сделать rebase ветки feature относительно ветки мастер. Нужно перейти в ветку feature: git checkout feature. Потом написать git rebase master. Чтобы внести эти изменения в глобальный репозиторий, надо написать git push origin feature --force.
Пуш надо делать обязательно с force, иначе будет неправильно.
_________________________от мужа_____________________________

.........................от паши.............................
Ксения посмотри я поэтому руководству обучался гиту https://githowto.com/ru
........................от паши..............................
////////////////////////от саши баумгертнера/////////////////
По git лучше Сережи Сергеева не видел на русском видео
https://www.youtube.com/watch?v=xptx1b7EAPU
////////////////////////от саши баумгертнера/////////////////


далее следующий уровень https://learngitbranching.js.org/?locale=ru_RU:

СПОСОБЫ ПЕРЕМЕЩЕНИЯ ПО ДЕРЕВУ КОММИТОВ МОЕГО ПРОЕКТА

HEAD - имя текущего выбранного коммита (тот коммит над которым я в данный момент работаю)

HEAD всегда указывает на последний коммит из моего локального дерева

большинство команд git изменяющих рабочее дерево начинают с изменения HEAD

HEAD указывает на имя ветки (например bugFix) - когда я делаю коммит статус ветки bugFix меняется и это изменение видно через HEAD

где находится HEAD до коммита: C0-C1(main*head)
>git checkout C1
>git checkout main
>git commit
>git checkout C2
где находится HEAD после коммита: C0-C1-C2(main*head)

Detaching HEAD
detaching (отделение) HEAD - присвоение HEAD не ветке, а отдельному коммиту.

До отделения HEAD->main->C1:
С0-С1 (main*)
>git checkout C1
после отделения HEAD->C1:
с0-с1(main&HEAD)

задание:
отделить HEAD от ветки bugFix и присвоить HEAD последнему коммиту этой ветки.
указать коммит при помощи его идентификатора (hash (хеш)) в кружке на схеме
>git checkout C4

ОТНОСИТЕЛЬНЫЕ ССЫЛКИ

двигаться по дереву git при помощью хешей - не удобно (длинные например fed2da64c0efc5293610bdd892f82a58e8cbc5d8) но git нужно только первые несколько символов чтобы идентифицировать конкретный коммит например fed2.

>git log - чтобы найти хеш нужного коммита

но
git поддерживает относительные ссылки
можно начать с удобного места (например ветки bugFix или HEAD) и двигаться от него

способы:
>^ -перемещение на 1 коммит назад 
>~<num> -перемещение на несколько коммитов назад 

^+имя ссылки - указание найти родителя указанного коммита
>main^ - первый родитель ветки main
>main^^ - прародитель = родитель родителя

c0-c1-c2(main*)
>git checkout main^ - переключиться на коммит выше main 
c0-c1(HEAD)-c2(main)

можно использовать HEAD как относительную ссылку

пройти несколько раз назад по дереву коммитов:
с0-с1-с2-с3(main*)

>git checkout c3 - назначаю с3 HEAD
>git checkout HEAD^ - присваиваю HEAD коммиту выше с2
>git checkout HEAD^ - присваиваю HEAD коммиту выше с1
>git checkout HEAD^ - присваиваю HEAD коммиту выше с0

задание:
переместиться на первого родителя ветки bugFix
это отделит HEAD от ветки
использовать относительные ссылки

>git checkout C4
>git checkout HEAD^

ОПЕРАТОР "~"

если нужно переместиться на много шагов назад по дереву
^ несколько раз не удобно - поэтому оператор тильда ~

к тильде ~ можно добавить количество родительских коммитов, через которые нужно пройти

укажем после ~ число коммитов, через которые надо пройти

с0-с1-с2-с3-с4(main*)
>git checkout HEAD~4
с0(HEAD)-с1-с2-с3-с4(main)

перемещение ветки (branch forcing)
относительные ссылки используют для перемещения веток
можно напрямую прикрепить ветку к коммиту при помощи опции -f
>git branch -f main HEAD~3
-переместить ветку main на три родителя назад от HEAD

c0-c1-c2-c3-c4(main bugFix*)
>git branch -f main HEAD~3
c0-c1(main)-c2-c3-c4(bugFix*)
-с помощью HEAD~3 я перешла на 3 коммита назад и сделала тот коммит с1 - main


задание
передвинь HEAD main bugFix как показано на визуализации
1. git branch -f main C6
main теперь указывает на C6
2. git branch -f bugFix C0
bugFix теперь указывает на C0
3. git checkout C1
HEAD указывает на C1

ОТМЕНА ИЗМЕНЕНИЙ В GIT

на низком уровне:
добавление в коммит отдельных файлов и наборов строк
на высоком уровне:
изменения реально отменяются


>git reset
- отменяет изменения, перенося ссылку на ветку назад, на более старый коммит (переписывание истории)

reset для локальных веток и локальных репозиториев
reset не работает на удаленных ветках которые используют другие пользователи

С0-с1-с2(main*)
>git reset HEAD~1
C0-c1(main*)
гит просто перенес ссылку на main обратно на коммит с1
локальный репозиторий в состоянии как будто с2 никогда не существовал


>git revert
- перенесет ветку назад, как будто некоторых коммитов вовсе и не было

revert - отменить изменения и поделиться отмененными изменениями с остальными

с0-с1-с2(main*)
git revert HEAD
c0-c1-c2-c2'(main*)
появился новый коммит
новый коммит с2' содержит изменения полностью противоположные тем, что сделаны в коммите с2
после revert можно сделать push и поделиться изменениями с остальными

задание:
отменить 2 последних коммита в local (локальная ветка)
git reset HEAD~1
отменить 2 последних коммита в pushed (remote(удаленная) ветка
git checkout c2 (HEAD указывает на с2)
git revert HEAD (отменяю изменения и создаю противоположный коммит с2')
git branch -f pushed c2' (ветка pushed теперь указывает на c2')

ВВЕДЕНИЕ В CHERRY-PICK 
ПОПЕРЕМЕЩАЕМ ИЗМЕНЕНИЯ

git cherry-pick <commit1> <commit2> <...>
если хочу копировать несколько коммитов на место где сейчас нахожусь (HEAD)

у меня есть ветки:
c0-c1-c5main*
c2-c3-c4side
я хочу применить изменения ветки side в ветку main
я могу это сделать с помощью rebase, но с помощью чери-пик:
git cherry-pick c2 c4
и из ветки side переместились коммиты в ветку main*:
c0-c1-c5-c2'-c4'main*

задание:
скопируй изменения из этих трёх веток в мастер
git cherry-pick c3 c4 c7


ВВЕДЕНИЕ В ИНТЕРАКТИВНЫЙ REBASE
GIT INTERACTIVE REBASE

в случаях когда точно не известно какие коммиты нужны (и нет их хэшей)
интерактивный rebase - отобрать набор коммитов для rebase

для интерактивного ребейса нужна опция -i
гит открывает интерфейс просмотра того какие коммиты готовы к копированию на цель rebase (target) и показываются хэши коммитов и комментарии к ним - можно понять что к чему

интерфейс означает просто открытие файла в ребакторе типа vim 

после открытия окна интерактивного ребейса есть три варианта для каждого коммита
1) можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой)
2) можно "выкинуть" коммит из ребейза. для этого есть pick - переключение его означает, что нужно выкинуть коммит
3) можно соединить коммиты (объединять изменения двух коммитов)

c0-c1-c2-c3-c4-c5(main*)
>git rebase -i HEAD~4

C2-c3-c4-c5
c3(omit)-c2(omit)-c4(pick)-c5(omit)
c0-c1-c3'-c2'-c5(main*)

задача
переставь коммиты при помощи интерактивного rebase в таком порядке как показано на визуализации
всегда можно исправить ошибку вызвав команду undo или reset
c0-c1(overHere)-c2-c3-c4-c5(main*)
удалить с2 pick
после 3 будет 5 потом 4
c0-c1(overHere)-c3'-c5'-c4'(main*)

ответ:
>git rebase -i HEAD~4
в всплывающем окне: C2(pick) C3 (omit) c5(omit) c4(omit)


СБОРНАЯ СОЛЯНКА
ВЫБЕРЕМ ОДИН КОММИТ

когда мы пытаемся отследить ошибку, но она не очевидна
несколько команд для отладки и вывода

каждая отладочная команда вывода находится в своём коммите. в итоге мы нашли ошибку, исправили её и порадовались

я хочу добавить в main только исправление ошибки из ветки bugFix
если я воспользуюсь fast-forward - в main попадут также отладочные команды

другой способ:
надо заставить гит копировать только один из коммитов
>git rebase -i
>git cherry-pick

задание:
убедись, что в ветку main попал коммит, на который ссылается bugFix
git rebase -i HEAD~3
сделала для с4 - с4'(omit) все остальное (pick)
а потом смержила main и bugFix 
git merge bugFix
чтобы main встал на с4'

ЖОНГЛИРУЕМ КОММИТАМИ
>show commands

есть некоторые изменения newImage
и другие изменения caption
они связаны так, что находятся друг поверх друга в репозитории
иногда нужно внести небольшие изменения в более ранний коммит
надо немного поменять newImage хотя коммит в прошлом
как:
- переставить коммит так, чтобы нужный коммит находился наверху при помощи:
>git rebase -i
- внести изменения при помощи 
>git commit --amend
-переставь все обратно при помощи
git rebase -i
- переместить main на изменённую часть дереваЮ чтобы закончить уровень
(есть еще способ cherry-pick, но не в этот раз)
итоговое состояние:
мы дважды перемещаем коммиты, оба они получат по апострофу (еще один апостроф добавляется когда мы делаем git commit --amend
важно чтобы совпадало не только дерево коммитов, но и количество апострофов
git rebase -i HEAD~2
git commit --amend


нужно внести изменения в более ранний коммит
немного поменять newImage не смотря на то что коммит уже в прошлом
переставить коммит так чтобы нужны находился на верху с помощью git rebase -i
внести в него изменения при помощи git commit --amend (добавляется апостроф)
переставить все обратно при помощи git rebase -i
переместить main на измененную часть дерева чтобы закончить уровень

git rebase -i HEAD~1
git commit --amend
git rebase -i HEAD~2
git commit --amend
git commit --amend
git rebase -i HEAD~1
git checkout c3''
git rebase c2''' c3'' - тут у с3''добавился лишний апостроф!!
git merge main
git checkout c3'''
git branch -f main HEAD
git branch -f caption HEAD

ЖОНГЛИРУЕМ КОММИТАМИ №2
в прошлом уровне git rebase -i HEAD~1 чтобы переставить коммиты
когда коммит оказывался в конце я могла его изменить при помощи git commit --amend
но есть проблема - множество перестановок может спровоцировать конфликты
попробовать с помощью cherry-pick
cherry-pick поместить любой комммит сразу после HEAD (если этот коммит не предок HEAD)

с0-с1-с2 (bugFix)
    \
     с3 (main*)и видимо HEAD

git cherry-pick C2
копирую с2 на место где я сейчас нахожусь

с0-с1-с2 (bugFix)
    \
     с3-c2'(main*)

git checkout c1 (сделала с1 - HEAD)
git cherry-pick c2 (создала после с1 - с2')повис в воздухе по середине между с2 и с2''
git commit --amend (создала после с1 - с2'')
git cherry-pick c3 (после с2'' создался коммит с3') сейчас c3' это HEAD
git branch -f main HEAD (теперь последний коммит с3' это и HEAD и main


следующая тема GIT TAG
ветки просто двигать туда-сюда
ветки часто ссылаются на разные коммиты как на изменения в ветке
ветки просто изменить, ветки часто временны и постоянно меняют свое состояние

где взять постоянную ссылку на момент в истории изменений? для релиза и большого слияния нужно нечто более постоянное чем ветка

у тегов основная задача ссылаться постоянно на конкретный коммит.
после создания они никогда не сменят своего положения так что можно с легкостью сделать checkout конкретного момента в истории изменений.

создадим тег на с1 который будет нашей версией 1

c0-c1-c2(main*)

git tag v1 c1

c0-c1(v1)-c2(main*)

я назвала тег v1 и заставила его ссылаться на с1 (если не указать коммит с1 - гит пометит тегом HEAD)

задача:

создай теги так как показано на визуализации
потом перейди на тег v1 (ты перейдешь в состояние detached HEAD так как нельзя сделать комммит прямо в тег v1)

git tag v0 c1
(присвоила коммиту с1 тег v0)
git checkout c2
(сделала с2 HEAD)
git tag v1
(присвоила последнему коммиту HEAD тег v1)

git describe
теги - прекрасные ориентиры в истории измерений

git describe - команда которая показывает как далеко текущее состояние от ближайшего тега, помогает сориентироваться после отката на много коммитов по истории изменений (это нужно после git bisect или после отпуска)

>git describe <ref>
ref - что-либо что указывает на конкретный комммит
(если не указать ref то гит будет считать что указано текущее положение (HEAD)

<tag>_<numCommits>_g<hash>
где:
tag - это ближайший тег в истории изменений
numCommits - это на сколько далеко мы от этого тега
hash - хэш комммита, который описывается

с0(v1)-c1-c2(main)
        \
        c3-c4(side*)



>git tag v2 c3

команда git describe main выведет
v1_2_gC2
тогда как git describe side выведет:
v2_1_gC4

с0(v1)-c1-c2(main)
        \
        c3(v2)-c4(side*)

задача:
выполнить команду на нескольких коммитах
потом один коммит и уровень будет пройден
git tag v2 c4 (комммиту с4 присвоен тэг v2)
git tag v3 c5 (комммиту с5 присвоен тэг v3)

git describe (v3_1_gC6)
git describe main (v0_2_gC2)
git describe side (v2)
git describe bugFix (v3_1_gC6)
git commit

REBASE OVER 9000 раз
REBASE НА НЕСКОЛЬКИХ ВЕТКАХ

у нас куча веток
нужно перенести все изменения из них в мастер

начальство усложняет задачу тем что желает видеть все коммиты по порядку

после коммита с6' идет коммит c7'

если не получается - reset - начать с начала

!!БЕЗ cherry-pick

git rebase c2 c3 (c3' встал после с2)
git branch -f bugFix HEAD (HEADу присваиваю ветку bugFix)
git rebase c3' c4 (после с3' делаю с4)
git rebase c4' c5 (после с4' делаю с5)
git rebase c5' c6 (после с5' делаю с6)
git branch -f side HEAD (делаю последний коммит с6 HEAD веткой side)
git rebase c6' c7 (делаю после с6' коммит c7')
git branch -f another HEAD (последнему комммиту HEAD присваиваю ветку another)
git branch -f main HEAD (последнему коммиту HEAD присваиваю ветку main)

следующий уровень: здоровая семья или несколько родителей
определение родителей

так же как тильда ~ каретка ^ принимает номер после себя

~ количество коммитов на которые нужно откатиться назад

^ номер после ^ определяет на какого из родителей мерджа нужно перейти. мержевый коммит имеет двух родителей поэтому просто указать ^ нельзя. гит по умолчанию перейдет на "первого" родителя коммита, но указание номера после ^ изменяет это поведение

если мержевый коммит
git checkout main^
если перейдем на main^ без номера то попадем на первого родителя 

с0------с1--------с3(main*)
  \              /
   -----с2-------

git checkout main^

с0------с1(HEAD)--------с3(main)
  \                    /
   -----с2------------

как перейти на второго родителя

с0------с1--------с3(main*)
  \              /
   -----с2-------

git checkout main^2

с0------с1-------------с3(main)
  \                    /
   -----с2(HEAD)-------


модификаторы ^ ~ (каретка и тильда) сильно помогают перемещаться по дереву комитов:

с0------с1-------с2---------с6----с7(main*)
  \                         /
   с3----с4------с5---------

git checkout HEAD~ (на 1 коммит откатиться назад и встать на с6)

с0------с1-------с2---------с6(HEAD)----с7(main)
  \                         /
   с3----с4------с5---------

git checkout HEAD^2 (на второго родителя коммита с6 нужно перейти не поняла почему с6 это первый а с5 второй)

с0------с1-------с2---------с6----с7(main)
  \                         /
   с3----с4---------------с5(HEAD)

git checkout HEAD~2 (на два коммита нужно откатиться назад от HEAD на с5 и попадем на с3)

с0------с1-------с2---------с6----с7(main)
  \                         /
   с3(HEAD)----с4----------с5

эти модификаторы можно применять вместе например:
git checkout HEAD~^2~2 (откатить на один назад, на второго родителя и откатить на два коммита)

задача:
создать ветку в указанном месте
используя модификаторы (не указывая коммиты напрямую)


show commands


git checkout HEAD~ (поднялась на один коммит)
git checkout HEAD^2 (поднялась на второго родителя)
git checkout HEAD~ (поднялась на один коммит)
git branch bugWork (присвоила коммиту имя ветки bugWork)
git checkout main (звездочка присвоила ветке main звездочку *)

следующий уровень: спутанные ветки

есть несколько коммитов в ветках one, two, three
надо видоизменить эти три ветки при помощи более поздних коммитов из ветки main

ветки one нуждается в изменении порядка и удалении c5

ветка two требует полного перемешевания

ветка three хочет получить только один коммит

как пройти этот уровень решать мне, как найду решение сравнить его с нашим при помощи show solution, undo - удалить последнее изменение


git rebase -i HEAD~4 -создает с4' c3' c2'

git checkout c1 -перешла в коммит с1 чтобы от него вести ветку

git cherry-pick c5 -появляется ветка и из нее растет с5'

git cherry-pick с4' -под с5 появляется c4''

git cherry-pick с3' -под c4'' появляется c3''

git cherry-pick с2' -под c3'' появляется c2''

git branch -f two HEAD -коммиту с2'' присваивается ветка two

git checkout c2' -перехожу на коммит с2'

git branch -f one HEAD -коммиту с2' присваивается ветка one

git checkout c2 -перехожу на коммит с2

git branch -f three HEAD -коммиту с2 присваивается ветка three

git checkout c5 -перехожу на коммит с5

git branch -f main HEAD -коммиту c5 присваивается ветка main

УДАЛЕННЫЕ РЕПОЗИТОРИИ

push & pull - удалённые репозитории в GIT
(коллективное программирование)

1) введение в клонирование

удалённые репозитории - это копии вашего репозитория, храняющиеся на другом компьютере (связаться с другим компьютером через интернет и передавать коммиты туда и сюда)

свойства удалённых репозиториев:

- удалённый репозиторий - средство резервного копирования. локальные репозитории способны восстанавливать файлы используя предыдушие состояния, но вся эта информация хранится локального. потеряв все свои локальные данные я способна восстановить их при наличии копии своего репозитория на другом компьютере

- удалённые репозитории позволяют сделать процесс разработки более социальным, когда копия моего проекта размещена в другом месте мои друзья запросто могут внести свой вклад в мой проект или забрать последние и актуальные изменения.

использование веб-сайтов для визуализации активности удалённых репозиториев (gitHub) однако удалённые репозитории всегда выступают в качестве базы для таких инструментов.

git clone -команда для создания удалённого репозитория
команда создает локальную копию удаленного репозитория (например с гитхаб)

с0-с1(main*o/main)
git clone
с0-с1(main) - удаленный репозиторий

задача: git clone

следующий урок 2 удаленные ветки

после git clone что изменилось:
в локальном репозитории появилась новая ветка с именем o/main (это тип ветки называется удалённой веткой) и обладает рядом спецальных свойств
удалённые ветки отражают состояние удалённых репозиториев (с того момента как я обращалась к этим удалённым репозиториям в последний раз) они позволяют мне отслеживать и видеть разницу между моими локальными наработками и тем, что было сделано другими участниками 

важное свойство удалённых веток является тот факт что когда я извлекаю их - я отделяю (detaching) HEAD. гит делает это потому что я не могу работать непосредственно в этих веках, сперва мне необходимо сделать наработки где-то, а уж затем делиться ими с удалёнными репозиториями (после чего мои удалённые ветки будут обновлены)

что такое o/ в названии ветки? символ o/ в названии ветки служит для обозначения именно удалённых веток. удалённые ветки имеют обязательное правило именование в формате: <удалённый репозиторий>/<имя ветки> т.е. o/main = o - имя удалённого репозитория, main - имя ветки. большинство разработчиков именуют главные удалённые репозитории не как o а как origin, общепринятым является именование удалённого репозитория как origin когда я клонирую репозиторий командой git clone
o=origin в данном уроке так как не повещается на эдементах дизайна, на реальном проекте origin/main

пример:
извлечем check out удалённую ветку 

c0-c1(main*o/main) - локально
c0-c1(main) - удалённо

>git checkout o/main (git checkout origin/main)
>git commit

c0-c1(main o/main)-с2(HEAD) - локально
c0-c1(main) - удалённо

гит отделил (detached) HEAD и не обновил origin/main когда я добавила новый коммит с2 потому что origin/main обновиться тогда когда обновится сам удалённый репозиторий 

задача:
выполнить коммит единожды на main, а затем переключиться на origin/main и выполнить там коммит. (это наглядно продемонстрирует поведение удалённых веток и покажет как изменения влияют на состояние удалённых репозиториев)

с0-с1 (main*origin/main)-локально
c0-c1-c2(main)-удалённо

>git commit

c0-c1(origin/main)-c3(main*HEAD)-локально
c0-c1-c2(main)-удалённо

>git checkout c1 

c0-c1(origin/main HEAD)-c3(main)-локально
c0-c1-c2(main)-удалённо

>git commit 

c0-c1(origin/main)-c3(main)-локально
    \
    c4(HEAD)
c0-c1-c2(main)-удалённо

уровень 3: Git fetch 

работа с удалённые репозиториями сводится к передаче данных в и из других репозиториев
до тех пор пока мы можем отправлять коммиты туда-обратно мы можем делться любыми изменениями, которые отслеживают git 

git fetch - команда для извлечения данных ИЗ удалённого репозитория

как только я изменяю представление нашего удалённого репозитория - мои удалённые ветки обновятся соответствующим образом и отобразят это представление. это связывает git clone и git fetch

локально:
c0-c1(main*0/main)

удаленно: 
c0-c1-c2-c3(main)

>git fetch

локально:
c0-c1(main*)-c2-c3(o/main)

удаленно: 
c0-c1-c2-c3(main)

таким образом коммиты с2 и с3 были успешно скачаны в мой локальный репозиторий и удаленная ветка o/main отобразила эти изменения соответствующим образом

что делает fetch

- связывается с указанными удалённым репозиторием и забирает все те данные проекта, которных уменя еще нет, при этом:
- у меня появлются ссылки на все ветки из этого удалённого репозитория (o/main)

git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени

удалённые ветки отображают состояние удалённых репозиториев на тот момент когда я обращалась к ним в последний раз

git fetch механизм который дает возможность общаться с удалёнными репозиториями

git fetch общается с удалёнными репозиториями посредством интернета (через протоколы http:// или git://)

чего git fetch не делает - я не приведу всю свою локальную работу к такому же виду как на удалённом репозитории, git fetch это процедура скачивания, потом скаченные данные нужно слить с теми что до этого были локально (git fetch не модифицирует локальные файлы, для этого есть другая команда нужно потом написать какая)

задача:
запустить git fetch и скачать с удалённого репозитория в локальный репозиторий все коммиты
>git fetch 

следующий уровень: git pull

процедура скачивания (fetching) изменений с удаленной ветки и объединение (merging) настолько частая и распространенная, что git предоставляет вместо двух команд одну - git pull

уд с0-с1-с3(main)
лок с0-с1(origin/main)-с2(main*)
>git fetch - скачала С3 с удаленного репозитория
уд с0-с1-с3(main)
лок с0-с1-с2(main*)
        \
        c3(origin/main)    
>git merge o/main - объединяю с2 и с3 в один коммит
уд с0-с1-с3(main)
лок с0-с1-с2-----------------с4(main*)
        \                    /
        c3(origin/main)-----  

если использовать 
>git pull
произойдет тоже самое
т.е. git fetch, git merge o/main = git pull

следующий урок 5: коллективная работа 
























 




























